/*
 * Apolist: Attempt to retrieve information of parallelization
 *          generated by Open64 -apolist flag
 *          The information is stored in a *.list file and contains
 *          the following format:
 *          "Parallelization Log for Subprogram" <subprogram>
 *             <line_number> : <status>
 *             <messages 1>
 *             . . . 
 *             <messages n>
 */

//-----------------
// Header
#include "Apolist.h"


/**
 * Function prototype
 */ 

/**
 * Function Definition
 */ 

/**
 * getParStatus: retrieve status information and the messages (if exist)
 * input: 
 *   in: the stream file
 * input/output: 
 *   proginfo: object for the information collection
 * return:
 *   string of the line for the header to be treated by the caller
 *     empty if we need to read again the header (very unlikely)
 */ 
string getParStatus(ifstream &in, Proginfo &proginfo) {
  string str;
  int iPos;
  int iStatus=1; // 0=log header, 1=log status, 2=log messages
  bool needtoreadfile = true;
  while(!in.eof() && (iStatus==1)) {
     if(needtoreadfile)
       (getline(in,str));
     if((str.size()>2) && (str[0]==' ') && ((iPos=str.find(":"))>0 ) ) {
	   // we find the status and the line number
	   Lineinfo obj;
	   obj.lineno = atoi(str.substr(0,iPos).c_str());
	   obj.status = str.substr(iPos+1);
	   // now let's try to find the messages
	   iStatus = 2; // change status to look for messages
	   needtoreadfile = true;
	   while(!in.eof() && (iStatus==2)) {
	      if(getline(in,str)) {
		 if(str.size()>2) {
		   if(str[7]==' ') { // log messages
		     obj.info.push_back(str);
		   } else if(str[0]==' ') {
		     iStatus = 1; // log status
		     needtoreadfile = false;
		   } else {
		     iStatus = 0; // log header
		     needtoreadfile = false;
		   }
	         }
	      }
	   }
	   proginfo.lineinfo.push_back(obj);
     } else if(str.size()>2 && str[0]!=' ') {
	  iStatus = 0; // this must be a log header
	  needtoreadfile = false;
	  break;
     }
  }
  return str;
}
	
/**
 * Main function to retrieve info
 * Algo:
 * while(not eof) do
 *   if logHeader then
 *     retrieve subprogram name
 *     while(not eof AND logStatus) do
 *       retrive line number and status
 *       while(not eof AND logMessage) do
 *         retrieve message
 *       enddo
 *       update the database
 *     enddo
 *     update the database
 *   endif
 * enndo
 */ 
int loadFile(const char *filename, MapProginfo &mapProginfo) {
  ifstream in(filename);
  if(in) {
    string str="";
    int iPos;
    getline(in,str);
    while(!in.eof()){
       if(str.size()<2) { // read again the file if the line is empty
         getline(in,str);
       }
       // try to find the header log which contains the subprogram name
       if((str.size()>2) && (str[0]!=' ') && ((iPos=str.find("Subprogram"))>0 ) ) {
		  // this is the header line
	    Proginfo obj;
	    string program = str.substr(iPos+11); // retrieve the subprogram name
	    //obj.subprogram = str.substr(iPos+10); // retrieve the subprogram name
	    // get the status (if exist)
	    str=getParStatus(in, obj); 
	    mapProginfo[program] = obj;
	    //vecProginfo.push_back(obj); // store the subprogram info
       }
    }
    in.close();
    return 0;
  } else {
    cout<<"Error in opening:"<<filename<<endl;
    return -1;
  }
}

//-----------------
// Pilot test
// Active this pilot by using tag _TEST_ in the compiler option
#ifdef _TEST_
int main(int argc, char *argv[])
{
  if(argc>1) {
    MapProginfo proginfo;

    string x=argv[1];
    cout <<"Analyze:"<<x<<endl;
    cout<<"Return:"<<loadFile(argv[1], proginfo)<<endl;
    // 
    // check for the data correctness
    //
//    for(int j=0;j<proginfo.size();j++) {
//      cout <<"Program:"<<proginfo[j].subprogram<<endl;
    MapProginfo::iterator iter;
    for(iter=proginfo.begin(); iter!=proginfo.end(); iter++) {
      cout <<"Program" <<iter->first <<endl;
      for(int i=0;i<iter->second.lineinfo.size();i++) {
         cout <<"\tLine "<<iter->second.lineinfo[i].lineno<<" : "<<iter->second.lineinfo[i].status<<endl;
	 for(int k=0;k<iter->second.lineinfo[i].info.size();k++) {
	    cout <<"\t\t"<<iter->second.lineinfo[i].info[k]<<endl;
	 }
      }
      cout<<endl;
    }
  } else {
    cout <<"Usage: "<<argv[0]<<" Log_file"<<endl;
  }
}
#endif
