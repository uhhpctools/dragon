/* Prelude: *module*: header >>> */
/* <<< header ends. */
/*
** Generated by WorkShop Visual
*/
/*
**LIBS: -lXm -lXt -lX11
*/

#include <stdio.h>
#include <fstream.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>
#include <vector.h>    // STL vector.
#include <iostream.h>
#include <sstream>
#include <X11/Xatom.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <Xm/Xm.h>
#include <Xm/RepType.h>
#include <Xm/Protocols.h>
#include <Xm/MessageB.h>
#include <Xm/CascadeB.h>
#include <Xm/DialogS.h>
#include <Xm/FileSB.h>
#include <Xm/List.h>
#include <Xm/SelectioB.h>
#include <Xm/TextF.h>
#include <Xm/LabelG.h>
#include <Xm/PushBG.h>
#include <Xm/SeparatoG.h>
#include <Xm/Form.h>
#include <Xm/Label.h>
#include <Xm/PanedW.h>
#include <Xm/PushB.h>
#include <Xm/RowColumn.h>
#include <Xm/ScrollBar.h>
#include <Xm/Separator.h>
#include <Xm/Text.h>
//#include <Xbae/Matrix.h>

//#define SPLASH
#define DRAGONPATH "DRAGON_PATH"
/* Prelude: *module*: mainModule >>> */
/* <<< mainModule ends. */
#include "dragon.h"
#include "graphwindow.h"
#include "cfgwindow.h"
#include "ddgui.h"
#include "apolist/apogen.h"
#include "apolist/apogui.h"
#include "util/readfile.h"

bool CGwindowopen = False;
bool FGwindowopen = False;
bool FSwindowopen = False;
bool DDwindowopen = False;
bool Regionswindowopen = False;
bool ProgramActive = False;
bool RootNodeDetected= False;
char * SelectedFile = NULL;
void SelectSourceFiles(Widget, XtPointer, XtPointer) ;
void ExitProgram(Widget, XtPointer, XtPointer) ;
void KillProgram(Widget, XtPointer, XtPointer) ;
void OpenCallgraph(Widget, XtPointer, XtPointer) ;
void OpenFlowgraph(Widget, XtPointer, XtPointer) ;
void OpenHelp(Widget, XtPointer, XtPointer) ;
void LoadFileHelp(Widget, XtPointer, XtPointer) ;
void LoadFileStart(Widget, XtPointer, XtPointer) ;
void LoadFileCancel(Widget, XtPointer, XtPointer);
void LoadResources(void);
void PrintMessage(char[]);
void ConvertIR2UI(ifstream &);

void XDmanage_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtManageChild(*(Widget *) client_data);
}

void XDunmanage_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtUnmanageChild(*(Widget *) client_data);
}

void XDpopup_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtPopup(*(Widget *) client_data, XtGrabNone);
}

void XDpopdown_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtPopdown(*(Widget *) client_data);
}

void XDmap_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtMapWidget(*(Widget *) client_data);
}

void XDunmap_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtUnmapWidget(*(Widget *) client_data);
}

void XDenable_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtSetSensitive(*(Widget *) client_data, TRUE);
}

void XDdisable_link( Widget w, XtPointer client_data, XtPointer call_data)
{
	if (client_data && *(Widget *) client_data)
		XtSetSensitive(*(Widget *) client_data, FALSE);
}


Widget AppShell = (Widget) NULL;
Widget MainForm = (Widget) NULL;
Widget MenuBar = (Widget) NULL;
Widget ProjectCascade = (Widget) NULL;
Widget ProjectMenu = (Widget) NULL;
Widget ProjectSeparator1 = (Widget) NULL;
Widget OpenMenuButton = (Widget) NULL;
Widget ProjectSeparator2 = (Widget) NULL;
Widget ExitMenuButton = (Widget) NULL;
Widget ProjectSeparator3 = (Widget) NULL;
Widget AnalysisCascade = (Widget) NULL;
Widget AnalysisMenu = (Widget) NULL;
Widget AnalysisSeparator1 = (Widget) NULL;
Widget CallgraphMenuButton = (Widget) NULL;
Widget AnalysisSeparator2 = (Widget) NULL;
Widget FlowgraphMenuButton = (Widget) NULL;
Widget AnalysisSeparator3 = (Widget) NULL;
Widget DDMenuButton = (Widget) NULL;
Widget RegionsMenuButton = (Widget) NULL;
Widget AnalysisSeparator4 = (Widget) NULL;
Widget AnalysisSeparator5 = (Widget) NULL;
Widget HelpCascade = (Widget) NULL;
Widget HelpMenu = (Widget) NULL;
Widget HelpSeparator1 = (Widget) NULL;
Widget HelpMenuButton = (Widget) NULL;
Widget HelpSeparator2 = (Widget) NULL;
Widget MenuBarSeparator = (Widget) NULL;
Widget TopLabel = (Widget) NULL;
Widget TopLabelSeparator = (Widget) NULL;
Widget MainPanedWindow = (Widget) NULL;
Widget MainScrolledText = (Widget) NULL;
Widget MainHorScrollBar = (Widget) NULL;
Widget MainVertScrollBar = (Widget) NULL;
Widget MainText = (Widget) NULL;
Widget MessageScrolledText = (Widget) NULL;
Widget MessageHorScrollBar = (Widget) NULL;
Widget MessageVertScrollBar = (Widget) NULL;
Widget MessageText = (Widget) NULL;
Widget FileSelector = (Widget) NULL;
Widget FilterButton = (Widget) NULL;
Widget CancelButton = (Widget) NULL;
Widget HelpButton = (Widget) NULL;
Widget FileScrolledList = (Widget) NULL;
Widget FileList = (Widget) NULL;
Widget LoadFileButton = (Widget) NULL;
Widget SelectionText = (Widget) NULL;
Widget FilterText = (Widget) NULL;
Widget DirScrolledList = (Widget) NULL;
Widget DirectoryList = (Widget) NULL;
Widget SplashShell = (Widget) NULL;
Widget SplashBulletin = (Widget) NULL;
static Widget wShowStatusMenuButton = (Widget) NULL;
static Widget wSaveOMPMenuButton = (Widget) NULL;
static Widget wGenerateOMPMenuButton = (Widget) NULL;


UIGraphNode *UICallgraphRoot=NULL;
vector<CGEDGE> UICGEdges;
vector<regions> UIRegions;
vector<pregions> UIPregions;
int rootnode = 0;

vector<unsigned long> TextPos;

unsigned long TextP[10000];
unsigned int CGfdback; // by Liao




void PrintMessage(char Message[])
{

  char *TextToInsert = new char[strlen(Message)+2];
  strcpy(TextToInsert,Message);
  TextToInsert[strlen(Message)] = '\n';
  TextToInsert[strlen(Message)+1] = '\0';
  
  XmTextPosition CurPos;
  CurPos = XmTextGetInsertionPosition(MessageText);
  XmTextInsert(MessageText, CurPos, TextToInsert);

  CurPos = CurPos + strlen(TextToInsert);
  XmTextShowPosition(MessageText, CurPos);
  XmTextSetInsertionPosition(MessageText, CurPos);
  
  delete [] TextToInsert;


}




void OpenCallgraph(Widget, XtPointer, XtPointer)
{
  if (!CGwindowopen && ProgramActive)
    {
   Arg al[2];
  int ac;
  Position XPos = 0, YPos = 0; 
  ac = 0;
  XtSetArg(al[ac],XmNx,&XPos); ac++;
  XtSetArg(al[ac],XmNy,&YPos); ac++;
  XtGetValues(AppShell,al,ac);
  create_GraphShell(AppShell,XPos+605,YPos-25);
    }
  
  if (!ProgramActive)
    PrintMessage("Please select a project to open (*.d)");
    
}

void OpenDDgraph(Widget, XtPointer, XtPointer)
{
    
  if (!DDwindowopen && ProgramActive)
    {
     Arg al[2];
     int ac;
     Position XPos = 0, YPos = 0; 
     ac = 0;
     XtSetArg(al[ac],XmNx,&XPos); ac++;
     XtSetArg(al[ac],XmNy,&YPos); ac++;
     XtGetValues(AppShell,al,ac);
     create_DDShell(AppShell);//,XPos+605,YPos-25);
    }
  
  if (!ProgramActive)
    PrintMessage("Please select a project to open (*.d)");

}

void OpenRegions (Widget, XtPointer, XtPointer) 
{
  // add check if reginos windows is already open.
  if (!Regionswindowopen && ProgramActive)
    {
   Arg al[2];
  int ac;
  Position XPos = 0, YPos = 0; 
  ac = 0;
  XtSetArg(al[ac],XmNx,&XPos); ac++;
  XtSetArg(al[ac],XmNy,&YPos); ac++;
  XtGetValues(AppShell,al,ac); 
  //create_GraphShell(AppShell,XPos+605,YPos-25);
  create_InterRegionShell(AppShell);
   
    }
  
  if (!ProgramActive)
    PrintMessage("Please select a project to open (*.d)");




}



void OpenFlowgraph(Widget, XtPointer, XtPointer) 
{
  if (!FGwindowopen && ProgramActive) {
  Arg al[2];
  int ac;
  Position XPos = 0, YPos = 0;
  ac = 0;
  XtSetArg(al[ac],XmNx,&XPos); ac++;
  XtSetArg(al[ac],XmNy,&YPos); ac++;
  XtGetValues(AppShell,al,ac);
  create_CFGraphShell(AppShell,XPos+625,YPos-05);
  }
  if (!ProgramActive)
    PrintMessage("Please select a project to open (*.d)");
}

void LoadFileCancel(Widget CancelButtonWidget, XtPointer, XtPointer)
{ 
  FSwindowopen = False;
  XtUnmanageChild(XtParent(XtParent(XtParent(CancelButtonWidget))));
  XtDestroyWidget(XtParent(XtParent(XtParent(CancelButtonWidget))));
}

extern void UnHighlightText(void)
{
  unsigned long MaxPos= XmTextGetMaxLength(MainText);
  XmTextSetHighlight(MainText,0,MaxPos,XmHIGHLIGHT_NORMAL);
  

}

//--------
// Function to move the scrollbar into a specific position (the line number)
// 
void showScrollPosition(unsigned long lLineNumber) {
  int increment=0, value=0, slider, page;
  XmScrollBarGetValues(MainVertScrollBar, &value, &slider, &increment, &page);
  XmScrollBarSetValues(MainVertScrollBar, (int) lLineNumber - 1, slider, increment, page, True);

}

extern void HighlightLine(unsigned long LineNumber)
{
/* 
  if(LineNumber<TextPos.size()-1){
	XmTextSetHighlight(MainText,TextPos[LineNumber], TextPos[LineNumber+1],XmHIGHLIGHT_SELECTED);
	XmTextShowPosition(MainText, TextPos[LineNumber+1]+2);  
   	XmTextSetCursorPosition(MainText,TextPos[LineNumber]+1);  
  }
  */
  showScrollPosition(LineNumber);
}

void HighlightLines(unsigned long InitialLn,unsigned long FinalLn)
{
/*
  XmTextPosition CurposI = 0, CurposF = 0, SearchPosI, 
                 SearchPosF,  PreviousI = 0, PreviousF=0;
  Boolean FoundI = true, FoundF = true;
  char Pattern[] = "\n";

  for(unsigned long i = 0; i <=InitialLn && FoundI; i++)  
  {
    FoundI = XmTextFindString(MainText,CurposI,Pattern,XmTEXT_FORWARD, &SearchPosI);
    CurposI = SearchPosI+1;
   
    if(i < InitialLn) PreviousI = SearchPosI;
  }

 
  for(unsigned long i = 0; i <=FinalLn && FoundF; i++)  
  {
    FoundF = XmTextFindString(MainText,CurposF,Pattern,XmTEXT_FORWARD, &SearchPosF);
    CurposF = SearchPosF+1;
   
    if(i < FinalLn) PreviousF = SearchPosF;
  } */

	// laks 11/15/04 commented
	/*
  if(InitialLn<TextPos.size()-1 && FinalLn<TextPos.size()-1){
	XmTextSetHighlight(MainText,TextPos[InitialLn], TextPos[FinalLn+1],XmHIGHLIGHT_SELECTED);
	XmTextShowPosition(MainText, TextPos[FinalLn+1]+2);  
   	XmTextSetCursorPosition(MainText,TextPos[InitialLn]+1);  
  }*/

/*   XmTextSetHighlight(MainText,PreviousI+1, SearchPosF+1,XmHIGHLIGHT_SELECTED);
   XmTextShowPosition(MainText, SearchPosF+2);  
   XmTextSetCursorPosition(MainText,PreviousI+1); */

  showScrollPosition(InitialLn);
}

/* Highlight multiple lines */
extern void HighlightLines(vector<unsigned int> line_nums, int len)
{
  /*
  XmTextPosition Curpos = 0,  SearchPos, 
                  Previous = 0, First=0;
  Boolean Found = true;
  char Pattern[] = "\n";
  
  unsigned long i=0;
  int  j;

  if(len==0)
	return;
*/
  //for(j=0; j<len; j++){
   /* for(;i <=line_nums[j]-1 && Found; i++){
	Found = XmTextFindString(MainText,Curpos,Pattern,XmTEXT_FORWARD, &SearchPos);
    	Curpos = SearchPos+1;
    
    	if(i < line_nums[j]-1) Previous = SearchPos;

     }
     if(First==0) First=Previous; 
     XmTextSetHighlight(MainText,Previous+1, SearchPos+1,XmHIGHLIGHT_SELECTED); */
    /* if(line_nums[j]<TextPos.size())
	     XmTextSetHighlight(MainText,TextPos[line_nums[j]-1], TextPos[line_nums[j]],XmHIGHLIGHT_SELECTED);

  } 
 
     if(line_nums[0]<TextPos.size()){
       XmTextShowPosition(MainText, TextPos[line_nums[j-1]]+2);  
       XmTextSetCursorPosition(MainText,TextPos[line_nums[0]-1]);
   }
  */
  showScrollPosition(line_nums[0]);
}


void LoadFileHelp(Widget, XtPointer, XtPointer){}

/*********************
 * Static variables
 */ 
static VecParStatus parstatus;
static MapLineCodeStatus codestatus;
static bool bApolist = false; // indicate if the list file exists or not
static bool bOMPwritten = false; // indicate if the list file exists or not
static string strSourceCode;
static string strOpenMPCode;
static vector<string> vecSourceCode;

void updateMenuSensitive() {
  XtSetSensitive(wSaveOMPMenuButton, bOMPwritten);
  XtSetSensitive(wGenerateOMPMenuButton, bApolist);
  XtSetSensitive(wShowStatusMenuButton, bApolist);
}
// --------------------------------
// split: to convert a string with delimiter into vector of strings
// input: 
//    str: the input string
//    delimiters: the input delimiter (by default is the newline)
//    tokens: the output vector
//
template < class OI >
OI split(const std::string & input, const std::string & delims, OI dest)
{
    std::string::size_type first = 0, last = 0;
    while (first < input.size() && last != std::string::npos) {
        last = input.find_first_of(delims, first);
        *dest++ = input.substr(first, last - first);
        first = last+1;
    } 
    return dest;
} 

/**
 * DisplayVecSourceCode: 
 *  displaying a vector of source code into the main window text, 
 *  including the parallelization status.
 * input:
 *   vecStr: the input vector stirng
 */
void DisplayVecSourceCode(vector<string> vecStr) {
    char sLine[56];
    string strOut="";
    for(int iLine = 0; iLine < vecSourceCode.size(); iLine++ ) {
       int pLine = iLine + 1;
       if(bApolist) {                       // show the parallelization status
	 if(codestatus.find(pLine) != codestatus.end())
	    sprintf(sLine,"%4d %c:",pLine,codestatus[pLine]);
	 else
	    sprintf(sLine,"%4d  :",pLine);
       } else {
	 sprintf(sLine,"%4d  :",pLine);     // no parallelization status in this case
       }
       strOut = strOut + sLine + vecSourceCode[iLine] + "\n";
    }
    XmTextSetString(MainText, (char *)strOut.c_str());  // now display the main text
}

/* --------------
 * Functoin to display the source code into the main widget
 * This function will display the line number and the parallelization status
 *  (if exist) together with the source
 *  it will also update the TextPos for the new position of '\n'
 * input:
 *   string strText: the string contains pure source code
 */ 
void DisplaySourceCode(string strText) {
    
    long unsigned pos=0, oldpos=0;
    long unsigned origpos=0, origoldpos=0;
    char c;
    TextPos.clear();
    TextPos.push_back(1); 
//    vecOrigTextSource.clear();
//    vecOrigTextSource.push_back(1);

    int iLine, pLine=1;
    char sLine[56];
    
    // laks 11/15/04: using tokenize to detect the newline and store into a vector
    //Tokenize(strText, vecSourceCode);
    split(strText, "\n", back_inserter(vecSourceCode));
    DisplayVecSourceCode(vecSourceCode);
    /*
    string strOut="";
    for(iLine = 0; iLine < vecSourceCode.size(); iLine++ ) {
       pLine = iLine + 1;
       if(bApolist) {                       // show the parallelization status
	 if(codestatus.find(pLine) != codestatus.end())
	    sprintf(sLine,"%4d %c:",pLine,codestatus[pLine]);
	 else
	    sprintf(sLine,"%4d  :",pLine);
       } else {
	 sprintf(sLine,"%4d  :",pLine);     // no parallelization status in this case
       }
       strOut = strOut + sLine + vecSourceCode[iLine] + "\n";
    }
    XmTextSetString(MainText, (char *)strOut.c_str());  // now display the main text
    */
    /*
    for(iLine = 0; iLine < vecSourceCode.size(); iLine++ ) {
       string strbuf="";
       if(bApolist) {                       // show the parallelization status
	 if(codestatus.find(iLine) != codestatus.end())
	    sprintf(sLine,"%4d %c:",iLine,codestatus[iLine]);
	 else
	    sprintf(sLine,"%4d  :",iLine);
       } else {
	 sprintf(sLine,"%4d  :",iLine);     // no parallelization status in this case
       }
       strText.insert(oldpos, sLine);       // insert the additional info to the text
    }*/
    //
    //    laks 10.26.04:
    //    insert the line number and the parallelization status for each line
    /*
    pos=strText.find('\n');                 // look for a line break
    origpos = pos;
    while(pos<strText.size())  {            // line break exists ?
       string strbuf="";
       if(bApolist) {                       // show the parallelization status
	 if(codestatus.find(iLine) != codestatus.end())
	    sprintf(sLine,"%4d %c:",iLine,codestatus[iLine]);
	 else
	    sprintf(sLine,"%4d  :",iLine);
       } else {
	 sprintf(sLine,"%4d  :",iLine);     // no parallelization status in this case
       }
       strText.insert(oldpos, sLine);       // insert the additional info to the text
       vecOrigTextSource.push_back(origpos);
       pos = pos + strlen(sLine) + 1;
       TextPos.push_back(pos);              // store the line break position
       oldpos = pos;
       origoldpos = origpos;
       iLine++;
       pos=strText.find('\n',oldpos);       // look for another line break
       origpos = pos;
    }*/
    //XmTextSetString(MainText, (char *)strText.c_str());  // now display the main text

}

/**
 * Procedure to open a file give the name of the file. 
 * This function will read the source code, tries to open all needed auxilary files
 * such as cfg and list, and display it to the main text window.
 * 
 * input: Filename
 **/ 
extern void OpenFile(char *Filename)
{
    int fd;
    struct stat statb;
    char *text;
    unsigned long len; 
    if(!(fd = open(Filename, O_RDONLY)))
     {
       XtWarning("Error 02: Can't open file");
       //XtUnmanageChild(XtParent(w));
       //XtDestroyWidget(XtParent(w));
       PrintMessage("Error 2: can't open file:");
       PrintMessage(Filename); 
       return; 
 
     }          

      if(fstat(fd,&statb) == -1 || !(text = XtMalloc((len = statb.st_size)+1)))
      {
	 XtWarning("Error 03: Can't show text");
	 close(fd);
	 return; 
      } 
 
      else 
      {
	bApolist = listParStatus(parstatus, codestatus);
        updateMenuSensitive();
        (void) read(fd,text,len);
	 text[len]= 0;
	 //XmTextSetString(MainText,text); // laks 10.26.2004: not displayed yet
      }  
    string strText(text); // keep the text in the string
    close(fd);
    strSourceCode = strText; // copy the original source code into the main variable
    DisplaySourceCode(strText); // now display the source cde

    XtUnmanageChild(TopLabel);
    Arg al[2];
    int ac = 0;
    XmString Temp;
    Temp =  XmStringCreateLtoR (Filename, (XmStringCharSet)XmFONTLIST_DEFAULT_TAG ); 
    XtSetArg(al[ac],XmNlabelString,Temp); ac++;
    //XtSetArg(al[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    XtSetValues(TopLabel,al,ac); 
    XmStringFree(Temp);
    XtManageChild(TopLabel);

    XtFree(text);     
}


void LoadFileStart(Widget w, XtPointer client_data , XtPointer xt_call_data)
{
    
  XmFileSelectionBoxCallbackStruct *call_data = (XmFileSelectionBoxCallbackStruct *) xt_call_data;  
  SelectedFile=NULL;
  unsigned long len;
    
  
  if (call_data->length==0)
  {
      
     XtWarning("Error 04: You didn't select a file to open");
     XtUnmanageChild(XtParent(w));
     XtDestroyWidget(XtParent(w));
     return; 

  }
  
  else
  {  
    
     XmStringGetLtoR(call_data->value,XmSTRING_DEFAULT_CHARSET ,&SelectedFile);  
     // Here insert the call to the .B SelectedFile is the full path string for 
     //the .B
     if(SelectedFile[strlen(SelectedFile)-1]=='d' && SelectedFile[strlen(SelectedFile)-2]=='.' && SelectedFile[strlen(SelectedFile)]=='\0') 
       {  
         PrintMessage("Analyzing file."); 
	 // CallgraphVector = ParseDotBFile(SelectedFile);
         ifstream fin(SelectedFile,ios::in | ios::binary);
         ConvertIR2UI(fin);

	 //Debug, Liao
	 //	 for(int i=0;i<UIGraphNode::NumOfNodes;i++)
	   //	   UICallgraphRoot[i].PrintFeedback();

         fin.close();
	 OpenFile(UICallgraphRoot[rootnode].GetFilename());
         ProgramActive=True;       
	
          if (CGwindowopen) {

            CloseGraphWindow(NULL, NULL,NULL) ;   
             CGwindowopen = False;
            }
             if (FGwindowopen) {  
	       CloseCFGraphWindow(NULL,NULL,NULL);
	       FGwindowopen = False;
	    }
             if (DDwindowopen)
             {
               CloseDDGraph(NULL,NULL,NULL);   
               DDwindowopen = False;

             }
             if (Regionswindowopen)
	     {
	       CloseRegions(NULL,NULL,NULL);
               Regionswindowopen=false;

             }
                     
  
       }
     else
        PrintMessage("You didn't selected a .d file");  
       
  }
 

  XtUnmanageChild(XtParent(w));
  XtDestroyWidget(XtParent(w));
  FSwindowopen = False;
   
  //HighlightLine(UICallgraphRoot[0].GetLineNumber()-1);
     
		// HighlightLines(50,60);
		//HighlightLines(30,40);  
  // XmTextScroll(MainText, 50);
  
  
 
}


void ConvertIR2UI(ifstream &fin)
{
 // for call graph  edge
	   CGEDGE* tempEd;
  
  if (UICallgraphRoot!=NULL) delete [] UICallgraphRoot; 
  UICGEdges.clear();

  RootNodeDetected = False;
  int GraphSize = 0;
  fin.read((char *) &GraphSize, sizeof (int));
  UIGraphNode::NumOfNodes = GraphSize;  

  UIGraphNode::NumofMP = 0;
  //  UIGraphNode::CGfdback = 0;
  CGfdback=0;
//Yi Wen added on 06/30/2003: to decide if the graph is constructed by new cg alg
  bool newcg;
  fin.read((char *) &newcg, sizeof (bool));
  
  UIGraphNode::NewCG=newcg;  
 // UIGraphNode::NewCG = newcg;  
//end of Yi Wen added
  UICallgraphRoot = new UIGraphNode[GraphSize]; 
  // TODO: Add a check to see if the allocation was successful
 
  //ofstream out;
  //out.open("trace.t",ios::out);
  
  for (int i=0; i<GraphSize; i++)
  { 
    bool mp;
    char *data; 
    int len;
    int index;

    // Node Index
    fin.read((char *) &index, sizeof (int));
    // out << "["<<index<<"]: ";     

    // Has MP
    fin.read((char *) &mp, sizeof (bool));
    if(mp) UIGraphNode::NumofMP++;

    // Node Name
    fin.read((char *) &len, sizeof (int));
    data = new char[len];
    fin.read(data,len);
    // out << data<<", file=" ;
    if(strcmp(data,"MAIN__")==0 || strcmp(data,"main")==0) 
      {  
       rootnode = index;
       RootNodeDetected = True;
      }
    UICallgraphRoot[index].SetName(data);    
    UICallgraphRoot[index].SetIndex(index);
    delete [] data;
    
    
    UICallgraphRoot[index].SetMP(mp);   

    // filename
    fin.read((char *) &len, sizeof (int));
    data = new char[len];
    fin.read(data,len);
    // out <<data<< " ln=";
    UICallgraphRoot[index].SetFilename(data);    
    delete [] data;

    // LineNumber
    fin.read((char *) &len, sizeof (int));
    UICallgraphRoot[index].SetLineNumber(len);
    // out <<len<<endl;
    // out << "CALLS:\n";
    // Successors
 //Added by Liao for feedback information of current node
    //3/4/2004
    unsigned int n_wt;
    float caller_freq;
    float cycle;

    fin.read((char *)&n_wt,sizeof(unsigned int));
    fin.read((char *)&caller_freq,sizeof(float));
    fin.read((char *)&cycle,sizeof(float));
    if (caller_freq>=0.0) CGfdback = 1;
    UICallgraphRoot[index].Set_feedback(n_wt,caller_freq,cycle);
    //debug
    // cout <<"Debug node level:"<<"wt:"<<n_wt<<"freq"<<caller_freq
    // <<"cycle"<<cycle<<endl;

// end of feedback
    int totalsuccs = 0;
    fin.read((char *) &totalsuccs, sizeof (int));
    if (totalsuccs >0)
      {  
        int *succs = new int[totalsuccs]; 
        int *edges = NULL; 
        int *pre_edges = NULL; 
        int *pre_caller = NULL; 
	int *callsites_idx=NULL;
	int* vlist_idx=NULL;
	int* fake_idx=NULL;
        if(UIGraphNode::NewCG){  
        	edges = new int[totalsuccs]; 
        	pre_edges = new int[totalsuccs]; 
        	pre_caller = new int[totalsuccs]; 
		callsites_idx=new int[totalsuccs];
		vlist_idx=new int[totalsuccs];
		fake_idx=new int[totalsuccs];
	}
        for (int i=0; i < totalsuccs; i++)
         {  
	   int succsindex,e,pre_e,pre_n,c_idx;
           fin.read((char *) &succsindex, sizeof (int));
	  
	   //by Liao, for edge feedback info.
	   unsigned int ed_linenum;
	   unsigned int  ed_id;
	   float ed_freq;
	   fin.read((char *) &ed_linenum, sizeof (unsigned int));
	   fin.read((char *) &ed_id, sizeof (unsigned int));
	   fin.read((char *) &ed_freq, sizeof (float));
	   // for in edge
	   // CGEDGE* tempEd;
           {
           CGEDGE input(index, succsindex, ed_id, ed_linenum, ed_freq);
           UICGEdges.push_back(input);
           }
   
          tempEd= new CGEDGE(index, succsindex, ed_id, ed_linenum, ed_freq);
   //Debug 
   // tempEd->Print();
           UICallgraphRoot[succsindex].addInEdges(tempEd);
            
	   UICallgraphRoot[succsindex].addParents(index);
			// for outgoing edge
	   UICallgraphRoot[index].addOutEdges(tempEd);
           succs[i]=succsindex;
//Yi Wen added on 06/30/2003 for edge_index and previous edge index and
// previous edge's caller for convinence of later stage
//NOTE: modified many
         if(UIGraphNode::NewCG){  
           fin.read((char *) &e, sizeof (int));
	   fin.read((char*) &c_idx,sizeof(int));
           fin.read((char *) &pre_e, sizeof (int));
	   if(pre_e!=-1){
           	fin.read((char *) &pre_n, sizeof (int));
           	pre_caller[i]=pre_n;
	   }
	   else{
		pre_caller[i]=-1;
	   }
           edges[i]=e;
           pre_edges[i]=pre_e;
	   callsites_idx[i]=c_idx;
	   //cout <<"["<<succsindex<<"]"<<endl; 
 
	//read vlist
	int vsize;
	fin.read((char*) &vsize,sizeof(int));
	vector<int> vl;
	vl.clear();	
	//cout<<"vsize: "<<vsize<<"\n";
	for(int k=0;k<vsize;k++){
		int temp;
		fin.read((char*) &temp,sizeof(int));
		vl.push_back(temp); 
	}
	//cout<<"13\n";
	if(vsize>0){
		vlist_idx[i]=vlists.size();	
		vlists.push_back(vl);
	}else
		vlist_idx[i]=-1;

	//cout<<"1\n";
	//add fake edges
	vl.clear();
	fin.read((char*) &vsize,sizeof(int));
//	cout<<"e: "<<e<<", vsize: "<<vsize<<"\n";
	for(int k=0;k<vsize;k++){
		int temp;
		fin.read((char*) &temp,sizeof(int));
//		cout<<"temp: "<<temp<<"\n";
		vl.push_back(temp); 
	}
	if(vsize>0){
		fake_idx[i]=fake_edges.size();	
		fake_edges.push_back(vl);
	}else
		fake_idx[i]=-1;
	
	}//end of if(NewCG)
         }//end of for
		
	//UICallgraphRoot[index].SetCallsites(callsites,totalcallsites);
        UICallgraphRoot[index].SetSuccs(succs,edges,callsites_idx,pre_edges,pre_caller,vlist_idx,fake_idx,totalsuccs);
        //delet [] succs;
         
      }

    // out << endl;   
  } 
  // out.close();

 
  ProcedureLoaded = rootnode;

}



void SelectSourceFiles(Widget, XtPointer, XtPointer)
{
  // if (FSwindowopen) return;
        FSwindowopen = True;
	Widget children[13];      /* Children to manage */
	Arg al[64];                    /* Arg List */
	register int ac = 0;           /* Arg Count */
	XtPointer tmp_value;             /* ditto */
	XmString xmstrings[16];    /* temporary storage for XmStrings */
	Widget FSShell = (Widget)NULL;

	XtSetArg(al[ac], XmNallowShellResize, FALSE); ac++;
        XtSetArg(al[ac], XmNtitle, "Select File To Load"); ac++;
        XtSetArg(al[ac], XmNdialogStyle, XmDIALOG_PRIMARY_APPLICATION_MODAL); ac++;
        XtSetArg(al[ac], XmNdefaultPosition, TRUE);

	FSShell = XmCreateFormDialog ( AppShell,(char *) "FSShell", al, ac );
	
        Atom WmDeleteWindow = XmInternAtom(XtDisplay(FSShell),"WM_DELETE_WINDOW",False);
        XmAddWMProtocolCallback(FSShell, WmDeleteWindow,LoadFileCancel, NULL); 

        ac = 0;
	xmstrings[0] = XmStringCreateLtoR ( "OK", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNokLabelString, xmstrings[0]); ac++;
	XtSetArg(al[ac], XmNtextColumns, 20); ac++;
	xmstrings[1] = XmStringCreateLtoR ( "*.d", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNpattern, xmstrings[1]); ac++;
   
	FileSelector = XmCreateFileSelectionBox (FSShell, (char *) "FileSelector", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	XmStringFree ( xmstrings [ 1 ] );
	FilterButton = XmSelectionBoxGetChild ( FileSelector, XmDIALOG_APPLY_BUTTON );
	CancelButton = XmSelectionBoxGetChild ( FileSelector, XmDIALOG_CANCEL_BUTTON );
	HelpButton = XmSelectionBoxGetChild ( FileSelector, XmDIALOG_HELP_BUTTON );
	FileList = XmSelectionBoxGetChild ( FileSelector, XmDIALOG_LIST );
	LoadFileButton = XmSelectionBoxGetChild ( FileSelector, XmDIALOG_OK_BUTTON );
	SelectionText = XmSelectionBoxGetChild ( FileSelector, XmDIALOG_TEXT );
	FilterText = XmFileSelectionBoxGetChild ( FileSelector, XmDIALOG_FILTER_TEXT );
	DirectoryList = XmFileSelectionBoxGetChild ( FileSelector, XmDIALOG_DIR_LIST );
	FileScrolledList = XtParent ( FileList );

	DirScrolledList = XtParent ( DirectoryList );


	if (HelpButton)
	       XtAddCallback( HelpButton, XmNactivateCallback, LoadFileHelp, (XtPointer) 0 );
        if (CancelButton)
	       XtAddCallback( CancelButton,XmNactivateCallback, LoadFileCancel,(XtPointer) 0 );
	if (FileSelector != (Widget) 0)
	  	        XtAddCallback( FileSelector, XmNokCallback, LoadFileStart, (XtPointer) 0 );
	if (FileSelector != (Widget) 0) { XtManageChild ( FileSelector); }
        if (FSShell != (Widget) 0) { XtManageChild (FSShell); }

}

//Yi Wen modified on 07/13/2003 to enable finding dragon.res
//once user setup the correct DRAGON_PATH
void SetResources(void)
{
  char *dragon_dir=getenv(DRAGONPATH);
 // printf("dragon: %s\n",dragon_dir);
  char *rcfile=new char[200];
  if(dragon_dir)
	sprintf(rcfile,"%s/dragon.res",dragon_dir);
  else //current dir then
	sprintf(rcfile,"dragon.res");
 
  //char *path = getcwd(NULL,0);
  //char *rcfilepluspath = new char[(strlen (path)+ strlen (rcfile)+ 1)];
   
  //strcpy(rcfilepluspath,path);
  //strcat(rcfilepluspath,rcfile);
 // printf("rcfile: %s. plus: %s\n",rcfile,rcfilepluspath);
   setenv("XUSERFILESEARCHPATH",rcfile, TRUE);
  //   setenv("XUSERFILESEARCHPATH","dragon.res", TRUE);
//  delete [] rcfilepluspath;
 // delete [] path;
delete [] dragon_dir;
delete [] rcfile;
}

 void KillProgram(Widget, XtPointer,XtPointer)
{
   if (Regionswindowopen)
     {
	       CloseRegions(NULL,NULL,NULL);
               Regionswindowopen=false;

     }

   delete [] UICallgraphRoot;
   XtDestroyWidget(AppShell);
  exit(0);


}

/*
 * Function (callback) to save the OpenMP code into a file
 * */
// showMessage: function to display a message dialog box
static void showMessage(string strMsg) {
   Widget           dialog;
   Arg              arg[5];
   XmString         xms;
   int              n = 0;
      
   xms = XmStringCreateLocalized ((char*)strMsg.c_str());
   XtSetArg (arg[n], XmNmessageString, xms); n++;
   dialog = XmCreateInformationDialog(AppShell, "message", arg, n);
   XmStringFree (xms);
   XtManageChild(dialog);
}

/*
 * Function (callback) to save the OpenMP code
 * */
static void saveOMPCode(Widget w, XtPointer p1, XtPointer p2)
{
   string ext;
   string basename = getfilebasename(UICallgraphRoot[rootnode].GetFilename(), ext);
   basename += ".omp."+ext;
   ofstream file(basename.c_str());
   if(file.is_open()) {
      copy(vecSourceCode.begin(), vecSourceCode.end(), ostream_iterator<string>(file, "\n"));
      file.close();
      showMessage("File "+basename+" has been generated.");
   } else {
     cout <<"Error in opening "<<basename<<endl;
   }
}


/*
 * Function (callback) to generate the OpenMP code
 * */
static void generateOMP(Widget w, XtPointer p1, XtPointer p2)
{
	// we generate only if we have information from Apolist flag
    generateOpenMPCode(bApolist, vecSourceCode, codestatus);
    // since we have already generated the openMP code, we don't need the 
    // parallelization status
    bApolist = false;
    bOMPwritten = true;
    updateMenuSensitive();
    // display the source code generated
    DisplayVecSourceCode(vecSourceCode);
}

/*
 * Function (callback) to show parallelization status
 * */
static void showParallelStatus(Widget w, XtPointer p1, XtPointer p2)
{
   ShowAPOwindow(AppShell, parstatus);
}

//-----------------------
void ExitProgram(Widget, XtPointer, XtPointer)
{
  unsigned int    n = 0;
  Arg             args[9];
  char            ExitMessage[]="Do you want to quit now?";
  Widget          ExitMessageBox;
    
  n = 0;
  XtSetArg(args[n], XmNmessageString,  XmStringCreateLtoR(ExitMessage, XmSTRING_DEFAULT_CHARSET)); n++;
  XtSetArg(args[n], XmNokLabelString,XmStringCreateSimple("Quit Now")); n++;
  XtSetArg(args[n], XmNcancelLabelString,XmStringCreateSimple(" Cancel ")); n++;
  XtSetArg(args[n], XmNmessageAlignment, XmALIGNMENT_CENTER); n++;
  XtSetArg(args[n], XmNdialogTitle, XmStringCreateLtoR("Warning", XmSTRING_DEFAULT_CHARSET)); n++;
  XtSetArg(args[n], XmNdialogStyle, XmDIALOG_PRIMARY_APPLICATION_MODAL); n++;
  XtSetArg(args[n], XmNautoUnmanage, True); 

  ExitMessageBox = XmCreateWarningDialog(AppShell, "ExitMessageBox", args, n);
    
  XtAddCallback(ExitMessageBox, XmNokCallback, (XtCallbackProc)KillProgram, (XtPointer)NULL);
  XtManageChild(ExitMessageBox);

  UnHighlightText();

}


//-----------------------
void InitializeSplash(void)
{
#ifdef SPLASH
    Arg al[5];
    int ac;

    ac = 0;
    XtSetArg(al[ac], XmNallowShellResize, FALSE); ac++;
    XtSetArg(al[ac], XmNnoResize, TRUE); ac++;
    XtSetArg(al[ac], XmNtitle, "Welcome!"); ac++;
    XtSetArg(al[ac], XmNmwmDecorations,0); ac++;
    SplashShell = XmCreateDialogShell ( AppShell, (char *) "SplashShell", al, ac );
	
    ac = 0;
    XtSetArg(al[ac], XmNautoUnmanage, FALSE); ac++;
    XtSetArg(al[ac], XmNnoResize, TRUE); ac++;
    XtSetArg(al[ac], XmNdialogStyle, XmDIALOG_PRIMARY_APPLICATION_MODAL); ac++;
    SplashBulletin = XmCreateBulletinBoard ( SplashShell, (char *) "SplashBulletin", al, ac );    

#endif
}

void ShowSplash(Widget, XtPointer, XtPointer)
{
#ifdef SPLASH
    static Boolean FirstTime = True; 
    Arg al[1];
    if (FirstTime)
      {
         XtManageChild (SplashBulletin);
         XtManageChild (SplashShell);
         XmUpdateDisplay(SplashShell);
         GraphShell = XtCreatePopupShell ( (char *) "GraphShell", topLevelShellWidgetClass, AppShell, al, 0 );
          PicGraphForm = XmCreateForm (GraphShell, (char *) "PicGraphForm", al, 0 );
      
	  // sleep(5);
         XtUnmanageChild(SplashShell);
         XtDestroyWidget(SplashShell);
         FirstTime = False;
         PrintMessage("Initializing Interface.....Done.");
         PrintMessage("Loading Settings...........Done.");
         PrintMessage("Initializing Memory........Done.");
         PrintMessage("Please select a .d file to load.");
         SelectSourceFiles(NULL, NULL, NULL);
      }
#endif
}



	/* Prelude: AppShell: pre-create >>> */
void create_AppShell (Display *display, char *app_name, int app_argc, char **app_argv)
	/* <<< pre-create ends. */
{
	Widget children[15];      /* Children to manage */
	Arg al[64];                    /* Arg List */
	register int ac = 0;           /* Arg Count */
	XrmValue from_value, to_value; /* For resource conversion */
	XtPointer tmp_value;             /* ditto */
	XmString xmstrings[16];    /* temporary storage for XmStrings */
        

	/* Prelude: AppShell: pre-manage >>> */
	/* <<< pre-manage ends. */

	XtSetArg(al[ac], XmNallowShellResize, FALSE); ac++;
	XtSetArg(al[ac], XmNtitle, "Dragon Analysis Tool v1.0 - University of Houston"); ac++;
	XtSetArg(al[ac], XmNargc, app_argc); ac++;
	XtSetArg(al[ac], XmNargv, app_argv); ac++;
	AppShell = XtAppCreateShell ( app_name, (char *) "XApplication", applicationShellWidgetClass, display, al, ac );

         
        /* Binds the Window Manager tool buttons to the methid ExitProgram */        
        Atom WmDeleteWindow = XmInternAtom(XtDisplay(AppShell),"WM_DELETE_WINDOW",False);
        XmAddWMProtocolCallback(AppShell, WmDeleteWindow, ExitProgram, NULL); 
        
        InitializeSplash();
	ac = 0;
	/* Prelude: MainForm: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNshadowType, XmSHADOW_ETCHED_IN); ac++;
	MainForm = XmCreateForm ( AppShell, (char *) "MainForm", al, ac );
        XtAddCallback(MainForm, XmNfocusCallback, ShowSplash, (XtPointer) 0 );
	ac = 0;
	/* Prelude: MenuBar: pre-create >>> */
	/* <<< pre-create ends. */
	MenuBar = XmCreateMenuBar ( MainForm, (char *) "MenuBar", al, ac );
	/* Prelude: ProjectCascade: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Project", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	ProjectCascade = XmCreateCascadeButton ( MenuBar, (char *) "ProjectCascade", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: ProjectMenu: pre-create >>> */
	/* <<< pre-create ends. */
	if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
	from_value.addr = "white" ;
	from_value.size = strlen( from_value.addr ) + 1;
	to_value.addr = NULL;
	XtConvertAndStore (ProjectCascade, XmRString, &from_value, XmRPixel, &to_value);
	if ( to_value.addr )
	{
		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
	}
	}
	XtSetArg(al[ac], XmNentryBorder, 0); ac++;
	ProjectMenu = XmCreatePulldownMenu ( MenuBar, (char *) "ProjectMenu", al, ac );
	ac = 0;
	/* Prelude: ProjectSeparator1: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	ProjectSeparator1 = XmCreateSeparator ( ProjectMenu, (char *) "ProjectSeparator1", al, ac );
	ac = 0;
	/* Prelude: OpenMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Load File...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	OpenMenuButton = XmCreatePushButton ( ProjectMenu, (char *) "OpenMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	// -----
	// laks 11/10/04: create button save as ...
	xmstrings[0] = XmStringCreateLtoR ( "Save OpenMP Code", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	wSaveOMPMenuButton = XmCreatePushButton ( ProjectMenu, (char *) "wSaveOMPMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: ProjectSeparator2: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	ProjectSeparator2 = XmCreateSeparator ( ProjectMenu, (char *) "ProjectSeparator2", al, ac );
	ac = 0;
	/* Prelude: ExitMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Exit", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	ExitMenuButton = XmCreatePushButton ( ProjectMenu, (char *) "ExitMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: ProjectSeparator3: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	ProjectSeparator3 = XmCreateSeparator ( ProjectMenu, (char *) "ProjectSeparator3", al, ac );
	ac = 0;
	/* Prelude: AnalysisCascade: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Analysis", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	AnalysisCascade = XmCreateCascadeButton ( MenuBar, (char *) "AnalysisCascade", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: AnalysisMenu: pre-create >>> */
	/* <<< pre-create ends. */
	if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
	from_value.addr = "white" ;
	from_value.size = strlen( from_value.addr ) + 1;
	to_value.addr = NULL;
	XtConvertAndStore (AnalysisCascade, XmRString, &from_value, XmRPixel, &to_value);
	if ( to_value.addr )
	{
		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
	}
	}
	AnalysisMenu = XmCreatePulldownMenu ( MenuBar, (char *) "AnalysisMenu", al, ac );
	ac = 0;
	/* Prelude: AnalysisSeparator1: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	AnalysisSeparator1 = XmCreateSeparator ( AnalysisMenu, (char *) "AnalysisSeparator1", al, ac );
	ac = 0;
	/* Prelude: CallgraphMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Callgraph...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	CallgraphMenuButton = XmCreatePushButton ( AnalysisMenu, (char *) "CallgraphMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: AnalysisSeparator2: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	AnalysisSeparator2 = XmCreateSeparator ( AnalysisMenu, (char *) "AnalysisSeparator2", al, ac );
	ac = 0;
	/* Prelude: FlowgraphMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Flowgraph...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	FlowgraphMenuButton = XmCreatePushButton ( AnalysisMenu, (char *) "FlowgraphMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: AnalysisSeparator3: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	AnalysisSeparator3 = XmCreateSeparator ( AnalysisMenu, (char *) "AnalysisSeparator3", al, ac );

        ac = 0;
	/* Prelude: FlowgraphMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Array Data Dependence...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	DDMenuButton = XmCreatePushButton ( AnalysisMenu, (char *) "DDMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: AnalysisSeparator3: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	AnalysisSeparator4 = XmCreateSeparator ( AnalysisMenu, (char *) "AnalysisSeparator4", al, ac );
	ac = 0;
	/* Prelude: FlowgraphMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "Array Regions...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	RegionsMenuButton = XmCreatePushButton ( AnalysisMenu, (char *) "RegionsMenuButton", al, ac );
        XmStringFree ( xmstrings [ 0 ] );


	ac = 0;
        XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	AnalysisSeparator5 = XmCreateSeparator ( AnalysisMenu, (char *) "AnalysisSeparator5", al, ac );
	ac = 0;
	// -----
	// laks 11/10/04: create openmp generation
	xmstrings[0] = XmStringCreateLtoR ( "Generate OpenMP code", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	wGenerateOMPMenuButton = XmCreatePushButton ( AnalysisMenu, (char *) "GenerateOMPMenuButton", al, ac );
        XmStringFree ( xmstrings [ 0 ] );
	ac = 0;
	// laks 02/05/06: create parallelization status
	xmstrings[0] = XmStringCreateLtoR ( "Parallelization status", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	wShowStatusMenuButton = XmCreatePushButton ( AnalysisMenu, (char *) "ParallelizationMenuButton", al, ac );
        XmStringFree ( xmstrings [ 0 ] );
	ac = 0;

	/* Prelude: HelpCascade: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( " Help ", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	HelpCascade = XmCreateCascadeButton ( MenuBar, (char *) "HelpCascade", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: HelpMenu: pre-create >>> */
	/* <<< pre-create ends. */
	if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
	from_value.addr = "white" ;
	from_value.size = strlen( from_value.addr ) + 1;
	to_value.addr = NULL;
	XtConvertAndStore (HelpCascade, XmRString, &from_value, XmRPixel, &to_value);
	if ( to_value.addr )
	{
		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
	}
	}
	XtSetArg(al[ac], XmNpacking, XmPACK_COLUMN); ac++;
	HelpMenu = XmCreatePulldownMenu ( MenuBar, (char *) "HelpMenu", al, ac );
	ac = 0;
	/* Prelude: HelpSeparator1: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	HelpSeparator1 = XmCreateSeparator ( HelpMenu, (char *) "HelpSeparator1", al, ac );
	ac = 0;
	/* Prelude: HelpMenuButton: pre-create >>> */
	/* <<< pre-create ends. */
	xmstrings[0] = XmStringCreateLtoR ( "User's Guide...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	HelpMenuButton = XmCreatePushButton ( HelpMenu, (char *) "HelpMenuButton", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	/* Prelude: HelpSeparator2: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
	HelpSeparator2 = XmCreateSeparator ( HelpMenu, (char *) "HelpSeparator2", al, ac );
	ac = 0;
	/* Prelude: MenuBarSeparator: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	MenuBarSeparator = XmCreateSeparator ( MainForm, (char *) "MenuBarSeparator", al, ac );
	ac = 0;
	/* Prelude: TopLabel: pre-create >>> */
	/* <<< pre-create ends. */
	TopLabel = XmCreateLabel ( MainForm, (char *) "TopLabel", al, ac );
	/* Prelude: TopLabelSeparator: pre-create >>> */
	/* <<< pre-create ends. */
	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_IN); ac++;
	TopLabelSeparator = XmCreateSeparator ( MainForm, (char *) "TopLabelSeparator", al, ac );
	ac = 0;
	/* Prelude: MainPanedWindow: pre-create >>> */
	/* <<< pre-create ends. */
	MainPanedWindow = XmCreatePanedWindow ( MainForm, (char *) "MainPanedWindow", al, ac );
	/* Prelude: MainScrolledText: pre-create >>> */
	/* <<< pre-create ends. */

	if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
	  from_value.addr = "white" ;
	  from_value.size = strlen( from_value.addr ) + 1;
	  to_value.addr = NULL;
	  XtConvertAndStore (MainPanedWindow, XmRString, &from_value, XmRPixel, &to_value);
	  if ( to_value.addr )
	  {
		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
	  }
	} 
         //XtSetValues(MainText, al, ac);
	MainText = XmCreateScrolledText ( MainPanedWindow, (char *) "MainText", al, ac );
	ac = 0;
	MainScrolledText = XtParent ( MainText );

	XtSetArg(al[ac], XmNhorizontalScrollBar, &MainHorScrollBar); ac++;
	XtSetArg(al[ac], XmNverticalScrollBar, &MainVertScrollBar); ac++;
	XtGetValues(MainScrolledText, al, ac );
	ac = 0;
	/* Prelude: MainHorScrollBar: pre-create >>> */
	/* <<< pre-create ends. */
	/* Prelude: MainVertScrollBar: pre-create >>> */
	/* <<< pre-create ends. */
	/* Prelude: MainText: pre-create >>> */
	/* <<< pre-create ends. */
	/* Prelude: MessageScrolledText: pre-create >>> */
	/* <<< pre-create ends. */
	/* if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
	from_value.addr = "white" ;
	from_value.size = strlen( from_value.addr ) + 1;
	to_value.addr = NULL;
	XtConvertAndStore (MainPanedWindow, XmRString, &from_value, XmRPixel, &to_value);
	if ( to_value.addr )
	{
		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
	}
	}*/

	MessageText = XmCreateScrolledText ( MainPanedWindow, (char *) "MessageText", al, ac );
	ac = 0;
	MessageScrolledText = XtParent ( MessageText );

	XtSetArg(al[ac], XmNhorizontalScrollBar, &MessageHorScrollBar); ac++;
	XtSetArg(al[ac], XmNverticalScrollBar, &MessageVertScrollBar); ac++;
	XtGetValues(MessageScrolledText, al, ac );
	ac = 0;
	
	// laks 10.29.04: add info label
	
	XmString label = XmStringCreateLocalized("A: Automatically parallelized  S: Do-accross parallized  M: Manually parallelized  N: Not a parallel loop");

	XtSetArg(al[ac], XmNlabelString, label); ac++;
	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	Widget wLabelInfo = XmCreateLabel(MainForm,(char*)"LabelInfo",al,ac);
	ac = 0;
	
	/* Prelude: MessageHorScrollBar: pre-create >>> */
	/* <<< pre-create ends. */
	/* Prelude: MessageVertScrollBar: pre-create >>> */
	/* <<< pre-create ends. */
	/* Prelude: MessageText: pre-create >>> */
	/* <<< pre-create ends. */


	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( MenuBar,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, MenuBar); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( MenuBarSeparator,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, MenuBarSeparator); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( TopLabel,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, TopLabel); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( TopLabelSeparator,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, TopLabelSeparator); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNbottomWidget, wLabelInfo); ac++;
//	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( MainPanedWindow,al, ac );
	ac = 0;
	/* Prelude: MainForm: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MenuBar: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: ProjectCascade: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: ProjectMenu: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: ProjectSeparator1: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: OpenMenuButton: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (OpenMenuButton)
		XtAddCallback( OpenMenuButton, XmNactivateCallback, SelectSourceFiles, (XtPointer) 0 );
	/* Prelude: ProjectSeparator2: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: ExitMenuButton: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (ExitMenuButton)
		XtAddCallback( ExitMenuButton, XmNactivateCallback, ExitProgram, (XtPointer) 0 );
	/* Prelude: ProjectSeparator3: pre-manage >>> */
	/* <<< pre-manage ends. */
	if ((children[ac] = ProjectSeparator1) != (Widget) 0) { ac++; }
	if ((children[ac] = OpenMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = wSaveOMPMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = ProjectSeparator2) != (Widget) 0) { ac++; }
	if ((children[ac] = ExitMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = ProjectSeparator3) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	XtSetArg(al[ac], XmNsubMenuId, ProjectMenu); ac++;
	XtSetValues(ProjectCascade, al, ac );
	ac = 0;
	/* Prelude: AnalysisCascade: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: AnalysisMenu: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: AnalysisSeparator1: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: CallgraphMenuButton: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (CallgraphMenuButton)
		XtAddCallback( CallgraphMenuButton, XmNactivateCallback, OpenCallgraph, (XtPointer) 0 );
	/* Prelude: AnalysisSeparator2: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: FlowgraphMenuButton: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (FlowgraphMenuButton)
		XtAddCallback( FlowgraphMenuButton, XmNactivateCallback, OpenFlowgraph, (XtPointer) 0 );

        if (DDMenuButton)
                XtAddCallback( DDMenuButton, XmNactivateCallback, OpenDDgraph, (XtPointer) 0 );

        if (RegionsMenuButton)
                XtAddCallback( RegionsMenuButton, XmNactivateCallback, OpenRegions, (XtPointer) 0 );  
	
	/*------------- OpenMP support  */
        if (wGenerateOMPMenuButton)
                XtAddCallback( wGenerateOMPMenuButton, XmNactivateCallback, generateOMP, (XtPointer) 0 );  
        if (wSaveOMPMenuButton)
                XtAddCallback( wSaveOMPMenuButton, XmNactivateCallback, saveOMPCode, (XtPointer) 0 );  
        if (wShowStatusMenuButton)
                XtAddCallback( wShowStatusMenuButton, XmNactivateCallback, showParallelStatus, (XtPointer) 0 );  
	/* -------------- */
	
	/* Prelude: AnalysisSeparator3: pre-manage >>> */
	/* <<< pre-manage ends. */
	if ((children[ac] = AnalysisSeparator1) != (Widget) 0) { ac++; }
	if ((children[ac] = CallgraphMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = AnalysisSeparator2) != (Widget) 0) { ac++; }
	if ((children[ac] = FlowgraphMenuButton) != (Widget) 0) { ac++; }
        if ((children[ac] = DDMenuButton) != (Widget) 0) { ac++; }
        if ((children[ac] = RegionsMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = AnalysisSeparator3) != (Widget) 0) { ac++; }
	if ((children[ac] = wGenerateOMPMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = wShowStatusMenuButton) != (Widget) 0) { ac++; }
        if ((children[ac] = AnalysisSeparator4) != (Widget) 0) { ac++; }
        if ((children[ac] = AnalysisSeparator5) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	XtSetArg(al[ac], XmNsubMenuId, AnalysisMenu); ac++;
	XtSetValues(AnalysisCascade, al, ac );
	ac = 0;
	/* Prelude: HelpCascade: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: HelpMenu: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: HelpSeparator1: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: HelpMenuButton: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (HelpMenuButton)
		XtAddCallback( HelpMenuButton, XmNactivateCallback, OpenHelp, (XtPointer) 0 );
	/* Prelude: HelpSeparator2: pre-manage >>> */
	/* <<< pre-manage ends. */
	if ((children[ac] = HelpSeparator1) != (Widget) 0) { ac++; }
	if ((children[ac] = HelpMenuButton) != (Widget) 0) { ac++; }
	if ((children[ac] = HelpSeparator2) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	XtSetArg(al[ac], XmNsubMenuId, HelpMenu); ac++;
	XtSetValues(HelpCascade, al, ac );
	ac = 0;
	if ((children[ac] = ProjectCascade) != (Widget) 0) { ac++; }
	if ((children[ac] = AnalysisCascade) != (Widget) 0) { ac++; }
	if ((children[ac] = HelpCascade) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	/* Prelude: MenuBarSeparator: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: TopLabel: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: TopLabelSeparator: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MainPanedWindow: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MainScrolledText: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MainHorScrollBar: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MainVertScrollBar: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MainText: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (MainText != (Widget) 0) { XtManageChild(MainText); }
	if (wLabelInfo != (Widget) 0) { XtManageChild(wLabelInfo); }
	/* Prelude: MessageScrolledText: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MessageHorScrollBar: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MessageVertScrollBar: pre-manage >>> */
	/* <<< pre-manage ends. */
	/* Prelude: MessageText: pre-manage >>> */
	/* <<< pre-manage ends. */
	if (MessageText != (Widget) 0) { XtManageChild(MessageText); }
	if ((children[ac] = MenuBar) != (Widget) 0) { ac++; }
	if ((children[ac] = MenuBarSeparator) != (Widget) 0) { ac++; }
	if ((children[ac] = TopLabel) != (Widget) 0) { ac++; }
	if ((children[ac] = TopLabelSeparator) != (Widget) 0) { ac++; }
	if ((children[ac] = MainPanedWindow) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	if (MainForm != (Widget) 0) { XtManageChild ( MainForm); }

      
        updateMenuSensitive();
}


/* Global Declarations */

XtAppContext app_context = (XtAppContext) 0 ;
Display     *display     = (Display *)    0 ;

int main(int argc, char **argv)
{

	/* Enable Localisation of the Application */

	XtSetLanguageProc((XtAppContext) 0, (XtLanguageProc) 0, (XtPointer) 0) ;

	/* Initialise the X Toolkit */

	XtToolkitInitialize ();

	/* Create a Global Application Context */

	app_context = XtCreateApplicationContext ();

        /* Set the resources enviromental variable */
          
        SetResources();

	/* Open the Display */

	display = XtOpenDisplay(app_context, (String) 0, argv[0], "XApplication",
	                       (XrmOptionDescRec *) 0, 0,
	                       &argc, argv);
	if (display == (Display *) 0) {
		printf("%s: can't open display, exiting...\n", argv[0]);
		exit (-1);
	}

	/* This converter is not registered internally by Motif */

	XmRepTypeInstallTearOffModelConverter();

	/* Call the Create Procedures for the Dialogs in the Application */

	create_AppShell ( display, argv[0], argc, argv );

	/* Display the Primary Application Shell */

	XtRealizeWidget (AppShell);

	/* Entering X Main Loop... */

	XtAppMainLoop (app_context);

	/* NOTREACHED */

	exit (0);
}

/* Dummy definitions to satisify references from routines that got pulled
 * in by the header files but are never called
 */
/*
void
Signal_Cleanup (INT sig) { }
char *
Host_Format_Parm (INT kind, MEM_PTR parm)
{
    fprintf (stderr, "Internal: Host_Format_Parm () not implemented\n");
    return "";
}
 */  
































