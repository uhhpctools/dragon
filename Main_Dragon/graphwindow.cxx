/*
** Generated by WorkShop Visual
*/
/*
**LIBS: -lXm -lXt -lX11
*/

#include <stdlib.h>
#include <unistd.h>

#include <iostream.h>
#include <vector.h>
#include <string>
#include <X11/Xatom.h>
#include <X11/Intrinsic.h>
#include <Xm/RepType.h>
#include <Xm/Protocols.h>
#include <X11/Shell.h>
#include <Xm/ToggleB.h>
#include <Xm/Xm.h>
#include <Xm/CascadeB.h>
#include <Xm/DialogS.h>
#include <Xm/Form.h>
#include <Xm/Label.h>
#include <Xm/List.h>
#include <Xm/PanedW.h>
#include <Xm/PushB.h>
#include <Xm/RowColumn.h>
#include <Xm/ScrollBar.h>
#include <Xm/Separator.h>
#include <Xm/MessageB.h>
#include <Xm/TextF.h>
#include <Xm/Text.h>
#include "XmGraph/Graph.h"
#include "XmGraph/Arc.h"
#include "Xfwf/Board.h"
#include "Xfwf/Common.h"
#include "Xfwf/Frame.h"
#include "Xfwf/Label.h"
#include "Xfwf/Slider2.h"

#include "dragon.h"
#include "graphwindow.h"
#include "FGnode.h"
#include "ddgui.h"
#include "cfgwindow.h"
#include "vcg/GraphNode.h"
#include "vcg/PrintGraph.h"

//Yi Wen added on 06/30/2003/ for error message title box
#define ErrorDialogTitle "Dragon Tools Error Message"

//Yi Wen added on 07/01/2003/ for showing callchain info
#define PREEDGESTYLE "blue"
#define NEXTEDGESTYLE "green"
#define CALLCHAINSTYLE "yellow"
#define NOTICEArcWIDTH 3
#define CALLCHAINLINE  XmLineSolid 
#define NEXTEDGELINE  XmLineDoubleDash
#define PREEDGELINE  XmLineOnOffDash 

vector<Widget> callchainArcs;
vector<Widget> nextArc;
vector<Widget> preArc;
void setArcNotice(Widget arc, char* color,int lineStyle);

extern void OpenGraphHelp(Widget, XtPointer, XtPointer) ;
void CallgraphListSelection(Widget, XtPointer, XtPointer) ;
extern void ControlflowListSelection(Widget, XtPointer, XtPointer) ;


extern void SliderScroll(Widget, Widget, XfwfScrollInfo *);

extern Widget CreateAnEdge(Widget GraphWidget, char NodeLabel[], Widget SuperNode,char edgeLabel[]);
extern Widget CreateANode(Widget GraphWidget, char NodeLabel[]);
extern void LoadProcedure(Widget, XtPointer,  XtPointer);
//Yi Wen added on 07/06/2003 to handle select arc event
extern void selectArcFunc(Widget, XtPointer,  XtPointer);
//extern void unselectFunc(Widget, XtPointer,  XtPointer);

extern void PrintCallgraph(Widget, XtPointer,  XtPointer);
/*Yi Wen added on 06/27/2003*/
extern void toggleMultiEdge(Widget, XtPointer, XtPointer);
void showCallchain(Widget, XtPointer, XtPointer);
void showNextEdge(Widget, XtPointer, XtPointer);
void showPreEdge(Widget, XtPointer, XtPointer);

void CreateCallgraph(void);
void CreateFlowgraph(int NodeNum);
void UpdateGraph(int GraphNum);


// void UpdateGraph(Widget GraphWidget);


Widget GraphShell = (Widget) NULL;
Widget GraphForm = (Widget) NULL;
Widget TopGraphMenuGar = (Widget) NULL;
Widget GraphMenuCascade = (Widget) NULL;
Widget GraphGraphMenu = (Widget) NULL;
Widget GraphMenuSeparator1 = (Widget) NULL;
Widget GraphCloseButton = (Widget) NULL;
Widget GraphMenuSeparator12 = (Widget) NULL;
Widget GraphMenuSeparator2 = (Widget) NULL;
Widget GraphHelpMenuCascade = (Widget) NULL;
Widget GraphHelpMenu = (Widget) NULL;
Widget GraphHelpMenuSeparator1 = (Widget) NULL;
Widget GraphHelpButton = (Widget) NULL;
Widget GraphHelpMenuSeparator2 = (Widget) NULL;
Widget GraphPanedWindow = (Widget) NULL;
Widget GraphFormTop = (Widget) NULL;
Widget CallgraphScrolledList = (Widget) NULL;
Widget CallgraphVertScrollBar = (Widget) NULL;
Widget CallgraphHorScrollBar = (Widget) NULL;
Widget CallgraphList = (Widget) NULL;
Widget CallgraphListLabel = (Widget) NULL;
Widget CallgraphInfoLabel = (Widget) NULL;
Widget CallgraphLabel = (Widget) NULL;
Widget CallgraphForm = (Widget) NULL;
Widget GraphFormBotton = (Widget) NULL;
Widget ControlflowForm = (Widget) NULL;
Widget FlowgraphLabel = (Widget) NULL;
Widget GraphToolForm = (Widget) NULL;
Widget GraphToolTopSeparator = (Widget) NULL;
Widget Callgraph = (Widget) NULL;
Widget Flowgraph = (Widget) NULL;
Widget Callsitegraph = (Widget) NULL;
Widget CallgraphSlider = (Widget) NULL;
//Widget FlowgraphSlider = (Widget) NULL;
Widget separator14 = (Widget)NULL;
Widget ZoomOutButton = (Widget)NULL;
Widget ZoomInButton = (Widget)NULL;
Widget GraphPrintButton = (Widget)NULL;
/*Added by Yi Wen on 06/27/2003*/
Widget GraphMultiedgeButton = (Widget)NULL;
/*Added by Yi Wen on 06/30/2003*/
Widget GraphCallchainButton = (Widget)NULL;
Widget GraphNextedgeButton = (Widget)NULL;
Widget GraphPreedgeButton = (Widget)NULL;
Widget PicGraphForm = (Widget)NULL;
Widget CGMessageScrolledText = (Widget) NULL;
Widget CGMessageHorScrollBar = (Widget) NULL;
Widget CGMessageVertScrollBar = (Widget) NULL;
Widget CGMessageText = (Widget) NULL;




void clearNotice(vector<Widget> arc,Widget button);
const int CALLGRAPH = 0;
const int FLOWGRAPH = 1;
int ProcedureLoaded = 0;
int CGZoom = 0;
int FGZoom =0;
FGRAPH cfg;  // HL ++
/*Added by Yi Wen on 06/27/2003*/
int _multiple_edge=0;
void ZoomINCB(Widget CloseButtonWidget, XtPointer, XtPointer);
void ZoomOUTCB(Widget CloseButtonWidget, XtPointer, XtPointer);
void PrintCallgraph(Widget, XtPointer,XtPointer);
/* Yi Wen added on 06/27/2003*/
//void toggleMultiEdge(Widget, XtPointer, XtPointer);
char* prepareEdgeLabel(int idx,int succ);
void PrintErrorMessage(char Message[]);

void DeadCodeDetection(UIGraphNode *temp);

/* Chunhua Liao added on 3/37/2004 , for dynamic call graph menu items*/
int CG_fdback_flag=0;
Widget DynamicGraphButton=(Widget)NULL;
Widget GraphMenuSeparator1d=(Widget)NULL;

/** ------------------------------------------------
 * Functions implementation
 */ 

// function to verify if the file is already loaded or not
// if it's already in memory, then we don't need to open it again !
// input: filename
void myOpenFile(char *filename) {
  static char staticname[1024];
  if(strcmp(filename, staticname)==0)
      return;
  strcpy(staticname, filename);
  OpenFile(filename);
}

void CGPrintMessage(char Message[])
{

  char *TextToInsert = new char[strlen(Message)+2];
  strcpy(TextToInsert,Message);
  TextToInsert[strlen(Message)] = '\n';
  TextToInsert[strlen(Message)+1] = '\0';
  
  XmTextPosition CurPos;
  CurPos = XmTextGetInsertionPosition(CGMessageText);
  XmTextInsert(CGMessageText, CurPos, TextToInsert);

  CurPos = CurPos + strlen(TextToInsert);
  XmTextShowPosition(CGMessageText, CurPos);
  XmTextSetInsertionPosition(CGMessageText, CurPos);
  
  delete [] TextToInsert;


}



extern void CloseGraphWindow(Widget CloseButtonWidget, XtPointer, XtPointer)
{

  //	XmGraphDestroyAllArcs(Callgraph);
    UnHighlightText();
   CGwindowopen = False;
   // ProcedureLoaded = rootnode;
   XtUnmanageChild(GraphShell);
   
}


void CallgraphListSelection(Widget, XtPointer, XtPointer Calldata)
{
   XmListCallbackStruct *calld = (XmListCallbackStruct *) Calldata;

   int i = calld->item_position -1;
   // cout << "\nHello there";  
   //if (ProcedureLoaded != i){ 
    // XmListSelectPos(CallgraphList,i+1,False);
//           cout << "\n" << UICallgraphRoot[i].GetName() << endl;
             UnHighlightText();
           myOpenFile(UICallgraphRoot[i].GetFilename()); 
	   HighlightLine(UICallgraphRoot[i].GetLineNumber()-1);
           XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[i].GetUINode());
           XmGraphUnselectNode(Callgraph,UICallgraphRoot[ProcedureLoaded].GetUINode());
           XmGraphSelectNode(Callgraph,UICallgraphRoot[i].GetUINode());
	   ProcedureLoaded = i; //need to comment later
	   if (FGwindowopen)
           UpdateGraph(i);
           if (DDwindowopen)
	     UpdateDDGraph();
          //  if (Regionswindowopen)
	     //CreateRegions();
          

  
	    //      }
                                                                 
	 

	
   






}
void CallgraphSliderScroll(Widget Slider, XtPointer, XfwfScrollInfo *calldata)
{
  SliderScroll(Slider,Callgraph,calldata);
}

void FlowgraphSliderScroll(Widget Slider, XtPointer, XfwfScrollInfo *calldata)
{

  SliderScroll(Slider,Callsitegraph,calldata);
}


extern void SliderScroll(Widget Slider, Widget Parent, XfwfScrollInfo *calldata)
{
  Arg al[5];
  int ac, MaxValue,CurrentValue, SliderSize, Increment, PageIncrement; 
  Widget VerScrollBar, HorScrollBar, ScrollWindow = XtParent(XtParent(Parent));    
   
  ac = 0;
  XtSetArg(al[ac], XmNverticalScrollBar, &VerScrollBar); ac++;    
  XtSetArg(al[ac], XmNhorizontalScrollBar, &HorScrollBar); ac++;
  XtGetValues(ScrollWindow, al, ac);

  if (VerScrollBar)
  {
    ac = 0;
    XtSetArg(al[ac], XmNmaximum, &MaxValue); ac++; 
    XtGetValues(VerScrollBar,al,ac);

    XmScrollBarGetValues(VerScrollBar, &CurrentValue, &SliderSize, &Increment, &PageIncrement);
 
    if(SliderSize < MaxValue)
    {
     if ((calldata->vpos <= 1.0) && (calldata->vpos >= 0.0))
     {
      CurrentValue = (int)((MaxValue - SliderSize) * calldata->vpos);
      XmScrollBarSetValues(VerScrollBar,CurrentValue, SliderSize, Increment, PageIncrement, True);    
     }
   
    }

   }
  
  if (HorScrollBar)
  {
    ac = 0;
    XtSetArg(al[ac], XmNmaximum, &MaxValue); ac++; 
    XtGetValues(HorScrollBar,al,ac);

    XmScrollBarGetValues(HorScrollBar, &CurrentValue, &SliderSize, &Increment, &PageIncrement);
 
    if(SliderSize < MaxValue)
    {
      if ((calldata->hpos <= 1.0) && (calldata->hpos >= 0.0))
	{
           CurrentValue = (int)((MaxValue - SliderSize) * calldata->hpos);
            XmScrollBarSetValues(HorScrollBar,CurrentValue, SliderSize, Increment, PageIncrement, True);    

        }
     }

   }




}


void DeadCodeDetection(UIGraphNode *temp)
{

  temp->SetVisited(True);
  for(int i=0; i< temp->GetNumSuccs(); i++)
    {
      int  num = temp->GetSuccsID(i); 
      if(!UICallgraphRoot[num].GetVisited())
	{ 
          DeadCodeDetection(&UICallgraphRoot[num]);            
        }
    }    





}




void CreateCallgraph(void)
{

  //cout <<"\n Total Nodes" <<sizeof (UICallgraphRoot)<<endl;     

  //cout <<"\n NodesNUM: " <<UIGraphNode::NumOfNodes<<endl;     
//	cout<<"name: "<<UICallgraphRoot[2].GetName()<<"\n"; 
  callchainArcs.clear();
  nextArc.clear();
  preArc.clear();
  for (int i = 0; i <UIGraphNode::NumOfNodes; i++)
  { 
    XmString xmstring = XmStringCreateLtoR (UICallgraphRoot[i].GetName() , (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
   
    XmListAddItem(CallgraphList,xmstring,0); 
    XmStringFree(xmstring);
//	cout<<"1\n";
    if(UICallgraphRoot[i].GetVisited()== False )
     { 
         UICallgraphRoot[i].SetUINode(CreateAnEdge(Callgraph,UICallgraphRoot[i].GetName(),NULL,"test2"));
         UICallgraphRoot[i].SetVisited(True);

         if(i==rootnode && RootNodeDetected)
	   {
	     ColorWidget(UICallgraphRoot[i].GetUINode(),"purple",True);
           }
     }
/*Yi Wen modified on 06/27/2003 for multiple edge */
//	cout<<"2\n";
	int yi_numSuccs,num_succs;
	yi_numSuccs=UICallgraphRoot[i].GetRealNumSuccs();
	num_succs=UICallgraphRoot[i].GetNumSuccs();

    if(yi_numSuccs==0)ColorWidget(UICallgraphRoot[i].GetUINode(),"pale green",True);   
//	cout<<"succ_num:"<<yi_numSuccs<<" in "<<UICallgraphRoot[i].GetName()<<"\n";
     if(yi_numSuccs>0)
       {
/*Yi Wen modified on 06/27/2003 for multiple edge */
//	cout<<"3\n";
         for (int j =0; j<yi_numSuccs; j++)
           {
             int num,edge_id,callsite_linenum;
	     float freq;
	       num =  UICallgraphRoot[i].GetSuccsID(j);
	       
	     edge_id= UICallgraphRoot[i].out_calledges[j]->edge_id;
	     freq= UICallgraphRoot[i].out_calledges[j]->freq;
	     callsite_linenum= UICallgraphRoot[i].out_calledges[j]->callsite_linenum;
	     //debug
	     //printf("feedback for edge:id=%d, freq=%f, site=%d\n", edge_id, freq,callsite_linenum);
	     
//	cout<<"num:"<<num<<" in "<<UICallgraphRoot[i].GetName()<<"\n";
             char *name = UICallgraphRoot[num].GetName();
		char* label=NULL;
         	if(UIGraphNode::NewCG)  
			label=prepareEdgeLabel(i,j);
	     if (UICallgraphRoot[num].GetVisited() == False )
               {
		bool edge_visible=(j<num_succs);
		
                 UICallgraphRoot[num].SetUINode(CreateANode(Callgraph,UICallgraphRoot[num].GetName()));
                  UICallgraphRoot[num].SetVisited(True);
		  // UICallgraphRoot[num].SetHasParent(True);
               }//end if  
                  Arg al[5];
                  int ac = 0; 
    		xmstring = XmStringCreateLtoR (UICallgraphRoot[i].GetName(),(XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
   
                  XtSetArg(al[ac],XmNarcDirection, XmDIRECTED); ac++;
		  XtSetArg(al[ac],XmNdefaultPosition,"False"); ac++;
		 
//when in single edge mode, no need to show the labels
		  // if((_multiple_edge  || j>=num_succs) && UIGraphNode::NewCG){
   		 
		  //	}
                  string label_str;
                  if (freq>=0.0) 
                  {
                  char buff[20];
                  //int freqi = (int)freq;
                  sprintf (buff, "%.0f"    ,freq );

		  label_str = "";
                  label_str+=buff;
		  XtSetArg(al[ac],XmNmapLabel,"True"); ac++;
		  }
                  Widget NewArc = XmCreateAttachedArc(Callgraph,(char *)label_str.c_str(),UICallgraphRoot[i].GetUINode(), 
                                                      UICallgraphRoot[num].GetUINode(),
                                                      al,ac); 
                  UICallgraphRoot[i].out_calledges[j]->Arc = NewArc;
		   
		  UICallgraphRoot[i].SetCallgraphArcs(j,NewArc);
		  //cout<<"NewArc: "<<NewArc<<"\n";
    		  XmStringFree(xmstring);
		  //if(_multiple_edge || j<num_succs)
                  	XtManageChild(NewArc);     
//by Liao, set color according to its feedback information
		   if(freq>0.0) ColorWidget(NewArc, "red",False);

		  // UICallgraphRoot[UICallgraphRoot[i].GetSuccsID(j)].SetHasParent(True);

	   }
       } 

  }   

 
  //  UICallgraphRoot[rootnode].SetHasParent(True);
   
   for (int i = 0; i <UIGraphNode::NumOfNodes; i++)
    {
       UICallgraphRoot[i].SetVisited(False);
       
    }

   if(RootNodeDetected)
     {
      DeadCodeDetection(&UICallgraphRoot[rootnode]); 

   
    for (int i = 0; i <UIGraphNode::NumOfNodes; i++)
    {
      if (UICallgraphRoot[i].GetMP()){
        ColorWidget(UICallgraphRoot[i].GetUINode(),"orange",True);
      }

      if(!UICallgraphRoot[i].GetVisited())
	{
           ColorWidget(UICallgraphRoot[i].GetUINode(),"red",True);
           UICallgraphRoot[i].SetHasParent(True);
        } 
       
         UICallgraphRoot[i].SetVisited(False);
   
       
    }
     }
   ProcedureLoaded = rootnode;
   UnHighlightText();
   myOpenFile(UICallgraphRoot[ProcedureLoaded].GetFilename()); 
   HighlightLine(UICallgraphRoot[ProcedureLoaded].GetLineNumber()-1);
   
   XmListDeselectAllItems(CallgraphList);
   XmListSetPos(CallgraphList,ProcedureLoaded+1);  
   XmListSelectPos(CallgraphList,ProcedureLoaded+1,False);
   XmListSetKbdItemPos (CallgraphList, ProcedureLoaded+1);


   
   if (FGwindowopen) 
      UpdateGraph(ProcedureLoaded);
   if (DDwindowopen)
     UpdateDDGraph();
  // if (Regionswindowopen)
    // CreateRegions(); 



//   CGPrintMessage("this is a test");
}

extern void CreateFlowgraph(int NodeNum)
{

	char *PU_Name, *FileName;
	int len, n;
  	len=strlen(UICallgraphRoot[NodeNum].GetName());
	PU_Name = new char[len+1];
	strcpy(PU_Name, UICallgraphRoot[NodeNum].GetName());
	len = strlen(UICallgraphRoot[NodeNum].GetFilename());
	FileName = new char[len+5];
 	strcpy(FileName,UICallgraphRoot[NodeNum].GetFilename());
	for(n=len-1; n>0; n--)
		if(FileName[n]!='.')
			FileName[n]='\0';
		else
			break;
	if(n>0)
		strcat(FileName,"cfg");
	else{
		strcpy(FileName,UICallgraphRoot[NodeNum].GetFilename());
		strcat(FileName,".cfg");
	}

	cfg.Load_CFG(FileName,PU_Name);	// load CFG for a file
	//debuy Liao
	
	//cfg.Print();

	cfg.Modify_CFG();		
 // modify CFG to make it match its sour
//	cfg.Print();

//    Widget name;                         
	delete [] PU_Name;
	delete [] FileName;
//	return;


//  cout <<"\n Total Nodes" <<sizeof (UICallgraphRoot)<<endl;     
//  cout <<"\n Total Nodes " << cfg.GetSizeofFGnodes() << "\n";   
	/* Display the control flow graph by creating nodes and edges*/  
/* Step 1. Node level*/
  for (int i = 0; i <cfg.GetSizeofFGnodes(); i++)
  {
     if(cfg.FG_Nodes[i].Get_Redundant() == TRUE) continue;  // don't display redundant BBs


     if(cfg.FG_Nodes[i].Is_Visited() == FALSE){ 
         cfg.FG_Nodes[i].SetUINode(CreateAnEdge(Flowgraph,cfg.FG_Nodes[i].Get_Name(),NULL,NULL));
         cfg.FG_Nodes[i].Set_Visited(TRUE);
     }

     if(strcmp(cfg.FG_Nodes[i].Get_Kind(),"ENTRY")==0 || strcmp(cfg.FG_Nodes[i].Get_Kind(),"EXIT")==0)
	 ColorWidget(cfg.FG_Nodes[i].GetUINode(),"yellow",True);	
     else if(strcmp(cfg.FG_Nodes[i].Get_Name(),"DOSTART")==0 || strcmp(cfg.FG_Nodes[i].Get_Name(),"DOEND")==0 || strcmp(cfg.FG_Nodes[i].Get_Name(),"LOOP")==0)
	 ColorWidget(cfg.FG_Nodes[i].GetUINode(),"sky blue",True);
     else if(strcmp(cfg.FG_Nodes[i].Get_Name(),"BRANCH")==0)
	 ColorWidget(cfg.FG_Nodes[i].GetUINode(),"pale green",True); 
     else if(strcmp(cfg.FG_Nodes[i].Get_Name(),"REGIONSTART")==0 || strcmp(cfg.FG_Nodes[i].Get_Name(),"REGIONEXIT")==0)
	 ColorWidget(cfg.FG_Nodes[i].GetUINode(),"orange",True);

/* Step 3. edge level*/
     if(cfg.FG_Nodes[i].GetSizeofSuccs()>0){
         for (int j =0; j<cfg.FG_Nodes[i].GetSizeofSuccs(); j++){
             long num;
	     IDTYPE       edge_id; 
	     // IDTYPE       source;
	     // IDTYPE       destination;

	     //FB_EDGE_TYPE edge_type;
	     FB_FREQ      freq;
	     Arg al[5];
	     int ac = 0; 

             num =  cfg.FG_Nodes[i].GetIDofSuccs(j)-1;
	     if(num>=cfg.GetSizeofFGnodes() || num<0) continue;		      // avoid the BB node exceeds the total size
     	     if(cfg.FG_Nodes[num].Get_Redundant() == TRUE) continue;  // don't display redundant BBs

 //Get edge feedback information
	     edge_id= cfg.FG_Nodes[i].out_edge_vec[j]->identity; 
             freq= cfg.FG_Nodes[i].out_edge_vec[j]->freq;
	     //debug
	     //printf("edge id=%d, freq=%f\n",edge_id, freq._value);
             //char *name = UICallgraphRoot[NodeNum].Flowgraph[num].GetName();
	     
	     char *tempStr;// label for edge
	     tempStr=new char[10];
	     // strcpy(tempStr,"");
	     if(freq._value >=0)
	     sprintf(tempStr,"%.0f",freq._value);
		 else strcpy(tempStr,"");
	     if (cfg.FG_Nodes[num].Is_Visited() == FALSE){

                  cfg.FG_Nodes[num].SetUINode(CreateAnEdge(Flowgraph,cfg.FG_Nodes[num].Get_Name(),
                                              cfg.FG_Nodes[i].GetUINode(),tempStr));                   
                  cfg.FG_Nodes[num].Set_Visited(TRUE);
		  //set color of the edge according to feedback information , by Chunhua Liao
		  	WidgetList n=new Widget[5];// only one edge here between basic nodes here?
		  int numArc;
		  n=XmGraphGetArcsBetweenNodes(Flowgraph,cfg.FG_Nodes[i].GetUINode(), 
					       cfg.FG_Nodes[num].GetUINode(),&numArc);
                  if(numArc>1) printf("fatal error !! Contact the developer for CFG multiple edges!\n");
		  ac=0;
		  if(freq._value >0)
			ColorWidget(n[0],"red",False);

		  /*
		   if(freq._value >0)
		     { 
		       XtSetArg(al[ac],XmNmapLabel,"True");ac++;
		        XtSetValues(n[0],al,ac);
		      ColorWidget(n[0],"red",False);
		     }else{
		       XtSetArg(al[ac],XmNmapLabel,"False");ac++;
		        XtSetValues(n[0],al,ac);
		     }
		     */
		  
		     /*
{ 
Arg al[5];
                  int ac = 0; 
  XmString edgeLabel;
  char *tempStr;
  tempStr=new char[10];
  sprintf(tempStr,"%.0f",freq._value);
 
  edgeLabel=XmStringCreateLtoR(tempStr,XmSTRING_DEFAULT_CHARSET);

  ac=0;
  XtSetArg(al[ac],XmNlabelString,edgeLabel);ac++;
  XtSetArg(al[ac],XmNmapLabel,"True"); ac++;
  XtSetValues(n[0],al,ac);

  ColorWidget(n[0],"red",False);
  
  delete tempStr;
  XmStringFree(edgeLabel);
 XtManageChild(n[0]);  
 }  
*/
		  delete []n;

             }
	     else{
                 
                  XtSetArg(al[ac],XmNarcDirection, XmDIRECTED); ac++;
		  if (freq._value >0){
		    XtSetArg(al[ac],XmNmapLabel,"True"); ac++;
		  }
		 
		  //debug
		  // printf("Test tempStr, label:%s\n",tempStr);
                  Widget NewArc = XmCreateAttachedArc(Flowgraph,tempStr,cfg.FG_Nodes[i].GetUINode(), 
                                                      cfg.FG_Nodes[num].GetUINode(),
                                                      al,ac); 
		 
		  // set color of the edge according to feedback information , by Chunhua Liao
		  if(freq._value >0) 
		    {
 		    ColorWidget(NewArc,"red",False);
		    }
                  XtManageChild(NewArc);     

	     }
	     delete tempStr;

	   }
       } 


   }

  if(cfg.GetSizeofFGnodes()>0){
    //XmGraphMap(Flowgraph);      
    cfg.FG_Nodes[0].Insert_line_num(UICallgraphRoot[ProcedureLoaded].GetLineNumber());
    XmGraphCenterAroundWidget(Flowgraph,cfg.FG_Nodes[0].GetUINode());
  }   

  
  for (int i = 0; i <cfg.GetSizeofFGnodes(); i++)
    cfg.FG_Nodes[i].Set_Visited(False);

    /*10/05/04 Laks: insert debugging line for output on CFG loops *
     */
     //apogen();
     //listParStatus();

}
/*
extern void unselectFunc(Widget w, XtPointer client, XtPointer Calldata){
	XmGraphCallbackStruct *calld = (XmGraphCallbackStruct *) Calldata;
	cout<<"reason: "<<calld->reason<<"\n";
	cout<<"num: "<<calld->num_selected_arcs<<"\n";
	if(calld->selected_widgets)
		cout<<"1\n";
	else
		cout<<"null\n";
	if(calld->num_selected_arcs==0){
		XtSetSensitive(GraphCallchainButton,FALSE);
		XtSetSensitive(GraphNextedgeButton,FALSE);
		XtSetSensitive(GraphPreedgeButton,FALSE);
	}
}
*/







//Yi Wen added on 07/06/2003 for callback event
extern void selectArcFunc(Widget w, XtPointer client, XtPointer Calldata){
	XmGraphCallbackStruct *calld = (XmGraphCallbackStruct *) Calldata;
	//unsetArcNotice for callchains, next edges and pre edges if needed
	//bool unset_callchain=True;
	//bool unset_next=True;
	//bool unset_pre=True;

	bool unset;
	//int i;
        bool debug=false;
	Widget parent,kid; 
	XmGraphGetArcNodes (Callgraph, calld->widget, &parent, &kid);
	if(debug) {
	 ColorWidget(parent,"orange", True);
	 cout <<"llego";
	} 
      
        for (int i = 0; i<UIGraphNode::NumOfNodes; i++) 
    {  
      if(parent ==  UICallgraphRoot[i].GetUINode())
	{
	  //if (ProcedureLoaded != i){ 
	     XmListDeselectAllItems(CallgraphList);
             XmListSetPos(CallgraphList,i+1);  
             XmListSelectPos(CallgraphList,i+1,False);
             XmListSetKbdItemPos (CallgraphList,i+1);
         
	    //cout << "\n" << UICallgraphRoot[i].GetName() << endl;
             UnHighlightText();
           myOpenFile(UICallgraphRoot[i].GetFilename());

	   for (int j=0; j< UICallgraphRoot[i].out_calledges.size();j++)
	     { 
               if(calld->widget == UICallgraphRoot[i].out_calledges[j]->Arc) 
 
                  HighlightLine(UICallgraphRoot[i].out_calledges[j]->callsite_linenum-1);

             }
	   // if (UICallgraphRoot[i].out_calledges.size()==0)
	   //   HighlightLine(UICallgraphRoot[i].GetLineNumber()-1);
	   ProcedureLoaded = i; // need to comment later
	   if (FGwindowopen)
           UpdateGraph(i);
           if(DDwindowopen)
	     UpdateDDGraph();
       //    if(Regionswindowopen)
         //    CreateRegions();    
           return; }
                                                                 
      //	}

    }









    /*        XmGraphWidget  graph;
         ArcWidget       arc;
         Widget          *from, *to;

       XmGraphGetArcNodes will store in the from and to widgets the nodes
       associated with arc.
    */






	if(_multiple_edge&& UIGraphNode::NewCG){
		if(XmToggleButtonGetState(GraphCallchainButton)){
			if(!XmGraphIsSelectedArc(Callgraph,callchainArcs[0])){//unset callchain
				clearNotice(callchainArcs,GraphCallchainButton);
				callchainArcs.clear();
			}
		}
		if(XmToggleButtonGetState(GraphNextedgeButton)){
			if(!XmGraphIsSelectedArc(Callgraph,nextArc[0])){//unset callchain
				clearNotice(nextArc,GraphNextedgeButton);
				nextArc.clear();
			}
		}
		if(XmToggleButtonGetState(GraphPreedgeButton)){
			if(!XmGraphIsSelectedArc(Callgraph,preArc[0])){//unset callchain
				clearNotice(preArc,GraphPreedgeButton);
				preArc.clear();
			}
		}
	/*
		if(XmTogYgleButtonGetState(GraphCallchainButton)){
			i=0;
			while(i<callchainArcs.size()&&unset_callchain){
				if(XmGraphIsSelectedArc(Callgraph,callchainArcs[i])){//unset callchain
					unset_callchain=False;
				}
				i++;
			}
		}
		if(XmToggleButtonGetState(GraphNextedgeButton)){
			i=0;
			while(i<nextArc.size()&&unset_next){
				if(XmGraphIsSelectedArc(Callgraph,nextArc[i])){//unset callchain
					unset_next=False;
				}
				i++;
			}
		}
		if(XmToggleButtonGetState(GraphPreedgeButton)){
			i=0;
			while(i<preArc.size()&&unset_pre){
				if(XmGraphIsSelectedArc(Callgraph,preArc[i])){//unset callchain
					unset_pre=False;
				}
				i++;
			}
		}
		if(unset_callchain){
			clearNotice(callchainArcs,GraphCallchainButton);
			callchainArcs.clear();
		}
		if(unset_pre){
			clearNotice(preArc,GraphPreedgeButton);
			preArc.clear();
		}
		if(unset_next){
			clearNotice(nextArc,GraphNextedgeButton);
			nextArc.clear();
		}
		//set back:
		if(!unset_callchain){
			for(i=0;i<callchainArcs.size();i++)
				setArcNotice(callchainArcs[i],CALLCHAINSTYLE);
		}
		if(!unset_next){
			for(i=0;i<nextArc.size();i++)
				setArcNotice(nextArc[i],NEXTEDGESTYLE);
		}
		if(!unset_pre){
			for(i=0;i<preArc.size();i++)
				setArcNotice(preArc[i],PREEDGESTYLE);
		}
*/
	}

}
extern void LoadProcedure(Widget w, XtPointer client, XtPointer Calldata)
{
  XmGraphCallbackStruct *calld = (XmGraphCallbackStruct *) Calldata;

  if (calld->reason == XmCR_SELECT_NODE && XtIsSubclass(calld->widget,xmPushButtonWidgetClass))
  {
    for (int i = 0; i<UIGraphNode::NumOfNodes; i++) 
    {  
      if(calld->widget ==  UICallgraphRoot[i].GetUINode())
	{
	  //if (ProcedureLoaded != i){ 
	     XmListDeselectAllItems(CallgraphList);
             XmListSetPos(CallgraphList,i+1);  
             XmListSelectPos(CallgraphList,i+1,False);
             XmListSetKbdItemPos (CallgraphList,i+1);
         
	    //cout << "\n" << UICallgraphRoot[i].GetName() << endl;
             UnHighlightText();
           myOpenFile(UICallgraphRoot[i].GetFilename()); 
	   HighlightLine(UICallgraphRoot[i].GetLineNumber()-1);
	   ProcedureLoaded = i; // need to comment later
	   if (FGwindowopen)
           UpdateGraph(i);
           if(DDwindowopen)
	     UpdateDDGraph();
          // if(Regionswindowopen)
            // CreateRegions();
	   string text;
           text = UICallgraphRoot[i].GetName();
	   text +=": cycles=";
           
                  char buff[20];
                  //int freqi = (int)freq;
                  sprintf (buff, "%.0f"    , UICallgraphRoot[i].cycle);		 
                  text+=buff;

		  text +=", weight=";
                  sprintf (buff, "%d"    , UICallgraphRoot[i].weight);      
                  text+=buff; 
	   CGPrintMessage((char *)text.c_str());    
           return; //}
                                                                 
      } 

	}
   }
}

extern void LoadStatement(Widget w, XtPointer client, XtPointer Calldata)
{
   XmGraphCallbackStruct *calld = (XmGraphCallbackStruct *) Calldata;
  if (calld->reason == XmCR_SELECT_NODE && XtIsSubclass(calld->widget,xmPushButtonWidgetClass))
  {
    for (int i = 0; i <cfg.GetSizeofFGnodes(); i++)
    {  
      if(calld->widget ==  cfg.FG_Nodes[i].GetUINode())
	{
	   
	  //cout << "\n" << UICallgraphRoot[i].GetName() << endl;
             UnHighlightText();
	   if(cfg.FG_Nodes[i].GetSizeofLinenums()>0){
//	           OpenFile(UICallgraphRoot[ProcedureLoaded].GetFilename()); 
//	   for(int j=0; j<cfg.FG_Nodes[i].line_nums.size(); j++)
//		   HighlightLine(cfg.FG_Nodes[i].line_nums[j]-1);
		   HighlightLines(cfg.FG_Nodes[i].line_nums,cfg.FG_Nodes[i].GetSizeofLinenums());
	   }
           return;
                                                                 
	} 

	}
   }

} 

 
void create_GraphShell (Widget parent, Position XPos, Position YPos)
{
	Widget children[15];      /* Children to manage */
	XmString accelerator;
	Display *display = XtDisplay ( parent );
	Arg al[64];                    /* Arg List */
	register int ac = 0;           /* Arg Count */
	XrmValue from_value, to_value; /* For resource conversion */
	XtPointer tmp_value;             /* ditto */
	Pixel fg, bg;                    /* colour values for pixmaps */ 
	XmString xmstrings[16];    /* temporary storage for XmStrings */
	Widget separator8 = (Widget)NULL;
	Widget separator13 = (Widget)NULL;
        Widget CallgraphSliderSeparator = (Widget)NULL;
        Widget CallgraphSliderLabel = (Widget)NULL;
        Widget FlowgraphSliderLabel = (Widget)NULL;
        Widget FlowgraphSliderSeparator = (Widget)NULL;
        XfwfScrollInfo CallgraphSliderInfo, FlowgraphSliderInfo;
        
        CGwindowopen = True;
        CGZoom = 0; 
        ProcedureLoaded = 0;        
	XtSetArg(al[ac], XmNallowShellResize, TRUE); ac++;
	XtSetArg(al[ac], XmNtitle, "Dragon Analysis Tool v1.0 - Callgraph Window"); ac++;
        XtSetArg(al[ac], XmNheight, 700); ac++;
        XtSetArg(al[ac], XmNwidth,900); ac++;
        XtSetArg(al[ac], XmNx, XPos); ac++;
        XtSetArg(al[ac], XmNy, YPos); ac++;
	GraphShell = XtCreatePopupShell ( (char *) "GraphShell", topLevelShellWidgetClass, parent, al, ac );

        Atom WmDeleteWindow = XmInternAtom(XtDisplay(GraphShell),"WM_DELETE_WINDOW",False);
        XmAddWMProtocolCallback(GraphShell, WmDeleteWindow, CloseGraphWindow, NULL); 

	ac = 0;
	XtSetArg(al[ac], XmNautoUnmanage, FALSE); ac++;
        XtSetArg(al[ac], XmNheight, 700); ac++;
        XtSetArg(al[ac], XmNwidth,900); ac++;
        XtSetArg(al[ac], XmNx, XPos); ac++;
        XtSetArg(al[ac], XmNy, YPos); ac++;
	GraphForm = XmCreateForm ( GraphShell, (char *) "GraphForm", al, ac );
	ac = 0;
	TopGraphMenuGar = XmCreateMenuBar ( GraphForm, (char *) "TopGraphMenuBar", al, ac );
	xmstrings[0] = XmStringCreateLtoR ( "Graphs", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	XtSetArg(al[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
	GraphMenuCascade = XmCreateCascadeButton ( TopGraphMenuGar, (char *) "GraphMenuCascade", al, ac );
	ac = 0;
	XmStringFree ( xmstrings [ 0 ] );
	XtSetArg(al[ac], XmNentryBorder, 0); ac++;
	XtSetArg(al[ac], XmNpacking, XmPACK_COLUMN); ac++;
	GraphGraphMenu = XmCreatePulldownMenu ( TopGraphMenuGar, (char *) "GraphGraphMenu", al, ac );
        
        
	


        ac = 0;
        XtSetArg(al[ac],XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	GraphMenuSeparator1 = XmCreateSeparator ( GraphGraphMenu, (char *) "GraphMenuSeparator1", al, ac );

/*
	added by Yi Wen on 06/27/2003 for toggling multiple edge and single edge dispaly
*/
	ac = 0;
        xmstrings[0] = XmStringCreateLtoR ( "Multiple Edges", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	XtSetArg(al[ac],XmNaccelerator,"Ctrl<Key>m"); ac++;
        accelerator = XmStringCreateLtoR ( "Ctrl+M", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac],XmNacceleratorText,accelerator);ac++;
	GraphMultiedgeButton = XmCreateToggleButton(GraphGraphMenu, (char *) "GraphMulButton", al, ac ); 
	XmToggleButtonSetState (GraphMultiedgeButton ,_multiple_edge,False);
	XmStringFree(accelerator);
        ac = 0;
        XtSetArg(al[ac],XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	GraphMenuSeparator1 = XmCreateSeparator ( GraphGraphMenu, (char *) "GraphMenuSeparator3", al, ac );
/*
	added by Yi Wen on 06/30/2003 for displayng a call chain 
*/
	ac = 0;
        xmstrings[0] = XmStringCreateLtoR ( "Callchain", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac],XmNaccelerator,"Ctrl<Key>c"); ac++;
        accelerator = XmStringCreateLtoR ( "Ctrl+C", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac],XmNacceleratorText,accelerator);ac++;
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	GraphCallchainButton = XmCreateToggleButton ( GraphGraphMenu, (char *) "GraphCallchainButton", al, ac );          
	if(_multiple_edge && UIGraphNode::NewCG)
		XtSetSensitive(GraphCallchainButton,TRUE);
	else
		XtSetSensitive(GraphCallchainButton,FALSE);
/*
	added by Yi Wen on 07/03/2003 for displaying "Next Edge" of an edge 
*/
	ac = 0;
        xmstrings[0] = XmStringCreateLtoR ( "Next Edges", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	XtSetArg(al[ac],XmNaccelerator,"Ctrl<Key>n"); ac++;
        accelerator = XmStringCreateLtoR ( "Ctrl+N", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac],XmNacceleratorText,accelerator);ac++;
	GraphNextedgeButton = XmCreateToggleButton ( GraphGraphMenu, (char *) "GraphNextedgeButton", al, ac );          
	if(_multiple_edge && UIGraphNode::NewCG)
		XtSetSensitive(GraphNextedgeButton,TRUE);
	else
		XtSetSensitive(GraphNextedgeButton,FALSE);

/*
	added by Yi Wen on 07/03/2003 for displaying "Next Edge" of an edge 
*/
	ac = 0;
        xmstrings[0] = XmStringCreateLtoR ( "Previous Edges", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
	XtSetArg(al[ac],XmNaccelerator,"Ctrl<Key>p"); ac++;
        accelerator = XmStringCreateLtoR ( "Ctrl+P", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac],XmNacceleratorText,accelerator);ac++;
	GraphPreedgeButton = XmCreateToggleButton ( GraphGraphMenu, (char *) "GraphPreedgeButton", al, ac );          
	if(_multiple_edge && UIGraphNode::NewCG)
		XtSetSensitive(GraphPreedgeButton,TRUE);
	else
		XtSetSensitive(GraphPreedgeButton,FALSE);
	/*separator 1*/
        ac = 0;
        XtSetArg(al[ac],XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	GraphMenuSeparator1 = XmCreateSeparator ( GraphGraphMenu, (char *) "GraphMenuSeparator1", al, ac );

        XmStringFree ( xmstrings [ 0 ] );

/*adding items for dynamic call graph, Liao */
	ac=0;	
	xmstrings[0] = XmStringCreateLtoR ( "Dynamic Call Graph", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++; // set label value pair

	XtSetArg(al[ac],XmNaccelerator,"Ctrl<Key>d"); ac++;   // set accelerator

        accelerator = XmStringCreateLtoR ( "Ctrl+D", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac],XmNacceleratorText,accelerator);ac++;
        // using arguments now
	//GraphMultiedgeButton = XmCreateToggleButton(GraphGraphMenu, (char *) "GraphMulButton", al, ac ); 
        DynamicGraphButton=XmCreateToggleButton(GraphGraphMenu, (char *) "DynamicGraphMulButton", al, ac );

	//XmToggleButtonSetState (DynamicGraphButton ,_multiple_edge,False);
	XmToggleButtonSetState (DynamicGraphButton ,0,False);
	
	if(CGfdback)
		XtSetSensitive(DynamicGraphButton,TRUE);
	else
		XtSetSensitive(DynamicGraphButton,FALSE);
	
	// add a separator here
	XmStringFree(accelerator);
        ac = 0;
        XtSetArg(al[ac],XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
	GraphMenuSeparator1d = XmCreateSeparator ( GraphGraphMenu, (char *) "GraphMenuSeparator3d", al, ac );

/* end of dynamic call graph */
	XmStringFree(xmstrings[0]);
  	ac = 0;
          xmstrings[0] = XmStringCreateLtoR ( "Print...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	GraphPrintButton = XmCreatePushButton ( GraphGraphMenu, (char *) "GraphPrintButton", al, ac );          
          XmStringFree ( xmstrings [ 0 ] );

          ac = 0;
      
  	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
  	GraphMenuSeparator12 = XmCreateSeparator ( GraphGraphMenu, (char *) "GraphMenuSeparator12", al, ac );
	

          ac = 0;
          xmstrings[0] = XmStringCreateLtoR ( "Close", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	GraphCloseButton = XmCreatePushButton ( GraphGraphMenu, (char *) "GraphCloseButton", al, ac );

  	ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );
  	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
  	GraphMenuSeparator2 = XmCreateSeparator ( GraphGraphMenu, (char *) "GraphMenuSeparator2", al, ac );
	
          /*end of menu 1*/
       



          ac = 0; 
  	xmstrings[0] = XmStringCreateLtoR ( "Help", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	XtSetArg(al[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
  	GraphHelpMenuCascade = XmCreateCascadeButton ( TopGraphMenuGar, (char *) "GraphHelpMenuCascade", al, ac );
  	ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );
  	XtSetArg(al[ac], XmNentryBorder, 0); ac++;
  	XtSetArg(al[ac], XmNpacking, XmPACK_COLUMN); ac++;
  	GraphHelpMenu = XmCreatePulldownMenu ( TopGraphMenuGar, (char *) "GraphHelpMenu", al, ac );
  	ac = 0;
  	XtSetArg(al[ac],XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
  	GraphHelpMenuSeparator1 = XmCreateSeparator ( GraphHelpMenu, (char *) "GraphHelpMenuSeparator1", al, ac );
  	xmstrings[0] = XmStringCreateLtoR ( "User's Guide...", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	GraphHelpButton = XmCreatePushButton ( GraphHelpMenu, (char *) "GraphHelpButton", al, ac );
  	ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );
  	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_OUT); ac++;
  	GraphHelpMenuSeparator2 = XmCreateSeparator ( GraphHelpMenu, (char *) "GraphHelpMenuSeparator2", al, ac );
  	ac = 0;
  	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
  	separator8 = XmCreateSeparator ( GraphForm, (char *) "separator8", al, ac );
  	ac = 0;
  	XtSetArg(al[ac], XmNheight, 659); ac++;
          XtSetArg(al[ac], XmNorientation, XmHORIZONTAL); ac++;
  	GraphPanedWindow = XmCreatePanedWindow ( GraphForm, (char *) "GraphPanedWindow", al, ac );
  	ac = 0;
          XtSetArg(al[ac], XmNheight,655); ac++;
          // XtSetArg(al[ac], XmNwidth,520); ac++;
          XtSetArg(al[ac], XmNwidth,885); ac++;
  	GraphFormTop = XmCreateForm ( GraphPanedWindow, (char *) "GraphFormTop", al, ac );
           ac = 0;
  	if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
  	from_value.addr = "white" ;
  	from_value.size = strlen( from_value.addr ) + 1;
  	to_value.addr = NULL;
  	XtConvertAndStore (GraphFormTop, XmRString, &from_value, XmRPixel, &to_value);
  	if ( to_value.addr )
  	{
  		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
  	}
  	} 
  	CallgraphList = XmCreateScrolledList ( GraphFormTop, (char *) "CallgraphList", al, ac );
  	ac = 0;
  	CallgraphScrolledList = XtParent ( CallgraphList );

  	XtSetArg(al[ac], XmNhorizontalScrollBar, &CallgraphHorScrollBar); ac++;
  	XtSetArg(al[ac], XmNverticalScrollBar, &CallgraphVertScrollBar); ac++;
  	XtGetValues(CallgraphScrolledList, al, ac );
  	/*
           ac = 0;
  	 if (DefaultDepthOfScreen(DefaultScreenOfDisplay(display)) != 1) {
  	from_value.addr = "white" ;
  	from_value.size = strlen( from_value.addr ) + 1;
  	to_value.addr = NULL;
  	XtConvertAndStore (GraphFormTop, XmRString, &from_value, XmRPixel, &to_value);
  	if ( to_value.addr )
  	{
  		XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
  	}
  	}
  	XtSetValues ( CallgraphList, al, ac ); */
  	ac = 0;
  	xmstrings[0] = XmStringCreateLtoR ( "Procedure List", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
          XtSetArg(al[ac], XmNwidth,150); ac++;
  	CallgraphListLabel = XmCreateLabel ( GraphFormTop, (char *) "CallgraphListLabel", al, ac );
  	ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );

          char templabel[100];
          strcpy(templabel,"Callgraph : Number of Procedures = ");
          char *buffer = itoa( UIGraphNode::NumOfNodes);
          strcat(templabel,(const char*)buffer);
  	delete [] buffer;
       	strcat(templabel, ", with OpenMP = ");
          buffer = itoa( UIGraphNode::NumofMP);
          strcat(templabel,(const char*)buffer);
  	delete [] buffer;


          xmstrings[0] = XmStringCreateLtoR (templabel, (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	CallgraphLabel = XmCreateLabel ( GraphFormTop, (char *) "CallgraphLabel", al, ac );
  	ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );
  	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_IN); ac++;
          XtSetArg(al[ac], XmNorientation,XmVERTICAL); ac++;
  	separator13 = XmCreateSeparator ( GraphFormTop, (char *) "separator13", al, ac );
  	ac = 0;
  	CallgraphForm = XmCreateForm ( GraphFormTop, (char *) "CallgraphForm", al, ac );
  	GraphFormBotton = XmCreateForm ( GraphPanedWindow, (char *) "GraphFormBotton", al, ac );
        
        


	//      ac = 0;
  	//xmstrings[0] = XmStringCreateLtoR ( "Callgraph Information", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	//XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	//CallgraphInfoLabel = XmCreateLabel ( CallgraphForm, (char *) "CallgraphInfoLabel", al, ac );
        //XmStringFree ( xmstrings [ 0 ] );
  	//ac = 0;

       
        ac = 0;
        XtSetArg(al[ac], XmNheight, 198); ac++;
        CGMessageText = XmCreateScrolledText (CallgraphForm, (char *) "CGMessageText", al, ac );
	ac = 0;


	CGMessageScrolledText = XtParent ( CGMessageText );
	XtSetArg(al[ac], XmNhorizontalScrollBar, &CGMessageHorScrollBar); ac++;
	XtSetArg(al[ac], XmNverticalScrollBar, &CGMessageVertScrollBar); ac++;
	XtGetValues(CGMessageScrolledText, al, ac );

    
          ac = 0;
     
          XtSetArg(al[ac], XmNorientation,XmHORIZONTAL); ac++;
          XtSetArg(al[ac], XmNautoLayoutMode, XmNEVER); ac++;
          XtSetArg(al[ac], XmNtwinsVisible, TRUE); ac++;
          XtSetArg(al[ac], XmNeditable, True); ac++;
          Callgraph = XmCreateScrolledGraph(CallgraphForm,"Callgraph", al, ac);

          /*  allow moving of nodes */
  	  XtAddCallback (Callgraph,
      		     XmNnodeMovedCallback,
      		     (XtCallbackProc)MoveHandling,   NULL);
        
          XtAddCallback (Callgraph,
      		     XmNarcMovedCallback,
      		     (XtCallbackProc)MoveHandling,    NULL);
         
           /*  avoid creation of new arcs or nodes */
          XtAddCallback (Callgraph,
      		     XmNnewNodeCallback,
      		     (XtCallbackProc)AvoidNew,     NULL);
      
          XtAddCallback (Callgraph,
      		     XmNnewArcCallback,
      		     (XtCallbackProc)AvoidNew,      NULL);
   
       
          XtAddCallback (Callgraph,
      		     XmNselectNodeCallback,
      		     (XtCallbackProc)LoadProcedure,  NULL);
         //Yi Wen added on 07/06/2003 to add callback function
          XtAddCallback (Callgraph,
      		      XmNselectArcCallback,
      		     (XtCallbackProc)selectArcFunc,  NULL);
         //Yi Wen added on 07/06/2003 to add callback function
         /* XtAddCallback (Callgraph,
  			XmNdeselectCallback,
      		     (XtCallbackProc)unselectFunc,  NULL);
  	*/
          /* 
    
          XtAddCallback(Callgraph,
      		    XmNselectArcCallback,
      		    (XtCallbackProc)CallSiteInfo,NULL);
          */

	  // CallgraphInfoLabel
	
       

          ac= 0;
           XtSetArg(al[ac], XmNtopAttachment, XmATTACH_NONE);ac++;
          XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM);ac++;
          XtSetValues (CGMessageScrolledText, al,ac);
  	
	  //  ac= 0;
	  //  XtSetArg(al[ac], XmNtopAttachment, XmATTACH_NONE);ac++;
	  /// XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_WIDGET);ac++;
          //XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM);ac++;
	  // XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM);ac++;
	  // XtSetArg(al[ac], XmNbottomWidget, CGMessageScrolledText); ac++;
	  // XtSetValues (CallgraphInfoLabel, al,ac);


          ac = 0;

          XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_WIDGET);ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNbottomWidget, CGMessageScrolledText); ac++;
	  // XtSetArg(al[ac], XmNbottomWidget,CallgraphInfoLabel ); ac++;
          
          XtSetValues (XtParent(XtParent(Callgraph)), al,ac);
       
        

  	ac = 0;
  	// XmStringFree ( xmstrings [ 0 ] );
  	XtSetArg(al[ac], XmNseparatorType, XmSHADOW_ETCHED_IN); ac++;
  	XtSetArg(al[ac], XmNorientation,XmHORIZONTAL); ac++;
  	separator14 = XmCreateSeparator ( GraphFormBotton, (char *) "separator14", al, ac );
	
  	ac = 0;
  	ControlflowForm = XmCreateForm ( GraphFormBotton, (char *) "ControlflowForm", al, ac );

          ac = 0;
     
          XtSetArg(al[ac], XmNorientation,XmHORIZONTAL); ac++;
          XtSetArg(al[ac], XmNautoLayoutMode, XmALWAYS); ac++;
          XtSetArg(al[ac], XmNtwinsVisible, TRUE); ac++;
          XtSetArg(al[ac], XmNeditable, True); ac++;
          Callsitegraph = XmCreateScrolledGraph(ControlflowForm,"Callsitegraph", al, ac);
          //Flowgraph = XmCreateScrolledGraph(ControlflowForm,"Flowgraph", al, ac);

          /*  allow moving of nodes */
          XtAddCallback (Callsitegraph,
      		     XmNnodeMovedCallback,
      		     (XtCallbackProc)MoveHandling,   NULL);
           /* avoid moving of arcs */
          XtAddCallback (Callsitegraph,
      		     XmNarcMovedCallback,
      		     (XtCallbackProc)MoveHandling,    NULL);
    
           /*  avoid creation of new arcs or nodes */
          XtAddCallback (Callsitegraph,
      		     XmNnewNodeCallback,
      		     (XtCallbackProc)AvoidNew,     NULL);
      
          XtAddCallback (Callsitegraph,
      		     XmNnewArcCallback,
      		     (XtCallbackProc)AvoidNew,      NULL);
   
       
          XtAddCallback (Callsitegraph,
      		     XmNselectNodeCallback,
      		     (XtCallbackProc)LoadStatement,  NULL);
          /*
          XtAddCallback(Callsitegraph,
      		    XmNselectArcCallback,
      		    (XtCallbackProc)CallSiteInfo,NULL);
          */




  	ac = 0;

          XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM);ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM);ac++;
          XtSetValues (XtParent(XtParent(Callsitegraph)), al,ac);

          ac = 0;
  	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
          XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNtopWidget, CallgraphScrolledList); ac++;
          XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
  	CallgraphSliderSeparator = XmCreateSeparator ( GraphFormTop, (char *) "CallgraphSliderSeparator", al, ac );        


          ac = 0;
  	//XmStringFree ( xmstrings [ 0 ] );
  	xmstrings[0] = XmStringCreateLtoR ( "Callgraph Slider", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
          XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNtopWidget, CallgraphSliderSeparator); ac++;
          XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
  	CallgraphSliderLabel = XmCreateLabel ( GraphFormTop, (char *) "CallgraphSliderLabel", al, ac );


          ac= 0; 
          CallgraphSlider = XtVaCreateManagedWidget("CallgraphSlider",
                                                 xfwfSlider2WidgetClass,
                                                 GraphFormTop,
                                                 XmNbottomAttachment, XmATTACH_NONE,
                                                 XmNrightAttachment, XmATTACH_WIDGET,
                                                 XmNtopAttachment, XmATTACH_WIDGET,
  					       XmNleftAttachment, XmATTACH_FORM,  
                                                 XmNrightWidget, separator13, 
                                                 XmNtopWidget, CallgraphSliderLabel,
  					       XmNheight,70,
  					       XmNwidth,80,
                                                 NULL);

  	CallgraphSliderInfo.hsize = CallgraphSliderInfo.vsize = 0.6;
          XfwfResizeThumb_Interface(CallgraphSlider, CallgraphSliderInfo.hsize, CallgraphSliderInfo.vsize);  
          XtAddCallback(CallgraphSlider,XtNscrollCallback, (XtCallbackProc)CallgraphSliderScroll, NULL);
          
          ac = 0;
  	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
          XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNtopWidget, CallgraphSlider); ac++;
          XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
  	FlowgraphSliderSeparator = XmCreateSeparator ( GraphFormTop, (char *) "FlowgraphSliderSeparator", al, ac );        


          ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );
  	xmstrings[0] = XmStringCreateLtoR ( "Callsite Slider", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
          XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
          XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
          XtSetArg(al[ac], XmNtopWidget, FlowgraphSliderSeparator); ac++;
          XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
  	FlowgraphSliderLabel = XmCreateLabel ( GraphFormTop, (char *) "FlowgraphSliderLabel", al, ac );


          ac= 0; 
  	/*  FlowgraphSlider = XtVaCreateManagedWidget("FlowgraphSlider",
                                                 xfwfSlider2WidgetClass,
                                                 GraphFormTop,
                                                 XmNbottomAttachment, XmATTACH_NONE,
                                                 XmNrightAttachment, XmATTACH_WIDGET,
                                                 XmNtopAttachment, XmATTACH_WIDGET,
  					       XmNleftAttachment, XmATTACH_FORM,  
                                                 XmNrightWidget, separator13, 
                                                 XmNtopWidget, FlowgraphSliderLabel,
  					       XmNheight,70,
  					       XmNwidth,80,
                                                 NULL);

  	FlowgraphSliderInfo.hsize = FlowgraphSliderInfo.vsize = 0.6;
          XfwfResizeThumb_Interface(FlowgraphSlider, FlowgraphSliderInfo.hsize, FlowgraphSliderInfo.vsize);  
          XtAddCallback(FlowgraphSlider,XtNscrollCallback, (XtCallbackProc)FlowgraphSliderScroll, NULL);
          */           

          ac = 0;

 	xmstrings[0] = XmStringCreateLtoR ( "Callsite", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
  	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
  	FlowgraphLabel = XmCreateLabel ( GraphFormBotton, (char *) "FlowgrahLabel", al, ac );
  	ac = 0;
  	XmStringFree ( xmstrings [ 0 ] );
  	XtSetArg(al[ac], XmNheight, 1); ac++;
  	GraphToolForm = XmCreateForm ( GraphForm, (char *) "GraphToolForm", al, ac );
  	ac = 0;
  	XtSetArg(al[ac], XmNseparatorType, XmSINGLE_DASHED_LINE); ac++;
  	GraphToolTopSeparator = XmCreateSeparator ( GraphToolForm, (char *) "GraphToolTopSeparator", al, ac );
  	ac = 0;
  	XtSetArg(al[ac], XmNforeground, &fg ); ac++;
  	XtSetArg(al[ac], XmNbackground, &bg ); ac++;
  	XtGetValues(GraphToolForm, al, ac );
  	ac = 0;
  	XtSetArg(al[ac], XmNbackgroundPixmap, XmGetPixmap ( XtScreen ( GraphToolForm ), "slant_right", fg, bg )); ac++;
  	//XtSetValues ( GraphToolForm, al, ac );
  	ac = 0;
       xmstrings[0] = XmStringCreateLtoR ( "Zoom Out", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
        XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	//	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
 
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
        XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
        XtSetArg(al[ac], XmNtopWidget, FlowgraphSliderSeparator); ac++;
        ZoomOutButton  = XmCreatePushButton ( GraphFormTop , (char *) "ZoomOutButton", al, ac );
	XtAddCallback( ZoomOutButton, XmNactivateCallback, ZoomINCB, (XtPointer) 0 );  
	// XtManageChild(ZoomOutButton);
        XmStringFree(xmstrings[0]);


        ac = 0;

        xmstrings[0] = XmStringCreateLtoR ( "Zoom In", (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
        XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	//	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
 
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
        XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
        XtSetArg(al[ac], XmNtopWidget, ZoomOutButton); ac++;
        ZoomInButton  = XmCreatePushButton ( GraphFormTop , (char *) "ZoomOutButton", al, ac );
        XtAddCallback( ZoomInButton, XmNactivateCallback, ZoomOUTCB, (XtPointer) 0 );  
	// XtManageChild(ZoomInButton);
         XmStringFree(xmstrings[0]);


         ac = 0;
	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
        XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
        XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
        XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
        XtSetArg(al[ac], XmNtopWidget, ZoomInButton); ac++;
        XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
	PicGraphForm = XmCreateForm ( GraphFormTop, (char *) "PicGraphForm", al, ac );
        XtManageChild(PicGraphForm);


        ac = 0; 
	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( TopGraphMenuGar,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, TopGraphMenuGar); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( separator8,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, separator8); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( GraphPanedWindow,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, GraphPanedWindow); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( GraphToolForm,al, ac );
	ac = 0;
	if (GraphCloseButton)
		XtAddCallback( GraphCloseButton, XmNactivateCallback, CloseGraphWindow, (XtPointer) 0 );
/*Added by Yi Wen on 06/27/2003*/
        if (GraphMultiedgeButton)
	  XtAddCallback(GraphMultiedgeButton, XmNvalueChangedCallback,toggleMultiEdge , (XtPointer) 0 );
/*Added by Yi Wen on 06/30/2003*/
        if (GraphCallchainButton)
	  XtAddCallback(GraphCallchainButton,  XmNvalueChangedCallback,showCallchain , (XtPointer) 0 );
/*Added by Yi Wen on 07/03/2003*/
        if (GraphNextedgeButton)
	  XtAddCallback(GraphNextedgeButton,  XmNvalueChangedCallback,showNextEdge , (XtPointer) 0 );
        if (GraphPreedgeButton)
	  XtAddCallback(GraphPreedgeButton,  XmNvalueChangedCallback,showPreEdge , (XtPointer) 0 );
        if (GraphPrintButton)
	  XtAddCallback(GraphPrintButton, XmNactivateCallback, PrintCallgraph, (XtPointer) 0 );
	if ((children[ac] = GraphMenuSeparator1) != (Widget) 0) { ac++; }
/*Added by Yi Wen on 06/27/2003*/
        if ((children[ac] = GraphMultiedgeButton) != (Widget) 0) { ac++; }
        if ((children[ac] = GraphCallchainButton) != (Widget) 0) { ac++; }
        if ((children[ac] = GraphNextedgeButton) != (Widget) 0) { ac++; }
        if ((children[ac] = GraphPreedgeButton) != (Widget) 0) { ac++; }
	if ((children[ac] = DynamicGraphButton)!=(Widget) 0){ ac++;}  // by Liao
	if ((children[ac] = GraphMenuSeparator1d)!=(Widget) 0) {ac++;}

        if ((children[ac] = GraphPrintButton) != (Widget) 0) { ac++; }
        if ((children[ac] = GraphMenuSeparator12) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphCloseButton) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphMenuSeparator2) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	XtSetArg(al[ac], XmNsubMenuId, GraphGraphMenu); ac++;
	XtSetValues(GraphMenuCascade, al, ac );
	ac = 0;
	if (GraphHelpButton)
		XtAddCallback( GraphHelpButton, XmNactivateCallback, OpenGraphHelp, (XtPointer) 0 );
	if ((children[ac] = GraphHelpMenuSeparator1) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphHelpButton) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphHelpMenuSeparator2) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	XtSetArg(al[ac], XmNsubMenuId, GraphHelpMenu); ac++;
	XtSetValues(GraphHelpMenuCascade, al, ac );
	ac = 0;
	if ((children[ac] = GraphMenuCascade) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphHelpMenuCascade) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, CallgraphListLabel); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
        XtSetArg(al[ac], XmNheight,300); ac++;
	XtSetArg(al[ac], XmNrightWidget, separator13); ac++;
	XtSetValues ( CallgraphScrolledList,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( CallgraphListLabel,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftWidget, separator13); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( CallgraphLabel,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftWidget, CallgraphListLabel); ac++;
	XtSetValues ( separator13,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, CallgraphLabel); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftWidget, separator13); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( CallgraphForm,al, ac );
	ac = 0;
	if (CallgraphList)
		XtAddCallback( CallgraphList, XmNbrowseSelectionCallback, CallgraphListSelection, (XtPointer) 0 );
	if (CallgraphList != (Widget) 0) { XtManageChild(CallgraphList); }
	if ((children[ac] = CallgraphListLabel) != (Widget) 0) { ac++; }
	// if ((children[ac] = CallgraphInfoLabel) != (Widget) 0) { ac++; }
	if ((children[ac] = CallgraphLabel) != (Widget) 0) { ac++; }
	if ((children[ac] = separator13) != (Widget) 0) { ac++; }
	if ((children[ac] = CallgraphForm) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;

	//XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	//XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	//XtSetValues ( CFNodeList,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
	XtSetValues ( separator14,al, ac );
	//	ac = 0;
    
	//XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	//XtSetArg(al[ac], XmNtopWidget, CFNodeList); ac++;
	//XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	//XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	//XtSetArg(al[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
	//XtSetArg(al[ac], XmNrightWidget, separator14); ac++;
	//XtSetValues ( ControlFlowScrolledList,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNtopWidget, FlowgraphLabel); ac++;
	XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftWidget, separator14); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( ControlflowForm,al, ac );
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	XtSetArg(al[ac], XmNleftWidget, separator14); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( FlowgraphLabel,al, ac );
        XtManageChild(FlowgraphLabel);
	ac = 0;
	//if (ControlFlowList)
	//XtAddCallback( ControlFlowList, XmNsingleSelectionCallback, ControlflowListSelection, (XtPointer) 0 );
	//if (ControlFlowList != (Widget) 0) { XtManageChild(ControlFlowList); }
	//if ((children[ac] = CFNodeList) != (Widget) 0) { ac++; }
	if ((children[ac] = separator14) != (Widget) 0) { ac++; }
	if ((children[ac] = ControlflowForm) != (Widget) 0) { ac++; }
	//if ((children[ac] = FlowgraphLabel) != (Widget) 0) { ac++; }
	
        if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	if ((children[ac] = GraphFormTop) != (Widget) 0) { ac++; }
	//if ((children[ac] = GraphFormBotton) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;

	XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	XtSetValues ( GraphToolTopSeparator,al, ac );
	ac = 0;
	if ((children[ac] = GraphToolTopSeparator) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
	ac = 0;
	if ((children[ac] = TopGraphMenuGar) != (Widget) 0) { ac++; }
	if ((children[ac] = separator8) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphPanedWindow) != (Widget) 0) { ac++; }
	if ((children[ac] = GraphToolForm) != (Widget) 0) { ac++; }
	if (ac > 0) { XtManageChildren(children, ac); }
       
               
       
	ac = 0;
        if (CallgraphSliderSeparator != (Widget)0) {XtManageChild (CallgraphSliderSeparator);}
        if (CallgraphSliderLabel != (Widget)0) {XtManageChild (CallgraphSliderLabel);}
	if (CallgraphSlider != (Widget) 0) {XtManageChild (CallgraphSlider);}
        if (FlowgraphSliderSeparator != (Widget)0) {XtManageChild (FlowgraphSliderSeparator);}
        if (ZoomInButton != (Widget)0) {XtManageChild (ZoomInButton);}
         if (ZoomOutButton != (Widget)0) {XtManageChild (ZoomOutButton);}
        //if (FlowgraphSliderLabel != (Widget)0) {XtManageChild (FlowgraphSliderLabel);}
	//if (FlowgraphSlider != (Widget) 0) {XtManageChild (FlowgraphSlider);}
        if (Callgraph != (Widget) 0) {XtManageChild (Callgraph); }
        if (Callsitegraph != (Widget) 0) {XtManageChild (Callsitegraph); }
	if (GraphForm != (Widget) 0) { XtManageChild ( GraphForm); }
         CreateCallgraph(); 
        if (GraphShell != (Widget) 0) {XtManageChild ( GraphShell); }

	//  CreateCallgraph(); 
	    
       
        XmGraphLayout(Callgraph);
        XmGraphLayout(Callsitegraph); 

 
        XmUpdateDisplay(Callgraph);
        XmUpdateDisplay(Callsitegraph);


	//       XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[0].GetUINode());
  //XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[i].GetUINode());
  // XmGraphUnselectNode(Callgraph,UICallgraphRoot[0].GetUINode());
	//         XmGraphSelectNode(Callgraph,UICallgraphRoot[0].GetUINode()); 

  XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[rootnode].GetUINode());
  //XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[i].GetUINode());
  // XmGraphUnselectNode(Callgraph,UICallgraphRoot[0].GetUINode());
           XmGraphSelectNode(Callgraph,UICallgraphRoot[rootnode].GetUINode()); 
                                     
}


Widget CreateANode(Widget GraphWidget, char NodeLabel[]){
    XmString NodeLabelString;
    Widget NewNode;
    Arg al[5];
    int ac;
    
   if(strlen(NodeLabel)>0)
   { 
    NodeLabelString = XmStringCreateLtoR(NodeLabel,XmSTRING_DEFAULT_CHARSET);
    NewNode = XtVaCreateManagedWidget("NewNode", xmPushButtonWidgetClass,
				      GraphWidget, XmNlabelString,
                                      NodeLabelString, NULL);
    XmStringFree(NodeLabelString);
	return NewNode;
	}
	return NULL;
}


Widget CreateAnEdgeDD(Widget GraphWidget, char NodeLabel[], Widget SuperNode,char edgeLabel[], char color[])
{
    XmString NodeLabelString;
    Widget NewNode, NewArc;
    Arg al[5];
    int ac;
    
   if(strlen(NodeLabel)>0)
   { 
    NodeLabelString = XmStringCreateLtoR(NodeLabel,XmSTRING_DEFAULT_CHARSET);
    NewNode = XtVaCreateManagedWidget("NewNode", xmPushButtonWidgetClass,
				      GraphWidget, XmNlabelString,
                                      NodeLabelString, NULL);

    XmStringFree(NodeLabelString);

    if(SuperNode)
    {
      ac = 0; 
      XtSetArg(al[ac],XmNarcDirection, XmDIRECTED); ac++;
	
      XtSetArg(al[ac],XmNmapLabel,"True"); ac++;
      XtSetArg(al[ac],XmNhighlightColor,"True"); ac++;
	//XtSetArg(al[ac],XmNstyle,lineStyle); ac++;	

      NewArc = XmCreateAttachedArc(GraphWidget,edgeLabel,SuperNode, NewNode,
                                   al,ac);
       ColorWidget(NewArc,color,False);
      XtManageChild(NewArc);     

     }

    return NewNode;
   }    

   else
     return NULL;
}

Widget CreateAnEdge(Widget GraphWidget, char NodeLabel[], Widget SuperNode,char* edgeLabel)
{
    XmString NodeLabelString;
    Widget NewNode, NewArc;
    Arg al[5];
    int ac;
    
   if(strlen(NodeLabel)>0)
   { 
    NodeLabelString = XmStringCreateLtoR(NodeLabel,XmSTRING_DEFAULT_CHARSET);
    NewNode = XtVaCreateManagedWidget("NewNode", xmPushButtonWidgetClass,
				      GraphWidget, XmNlabelString,
                                      NodeLabelString, NULL);

    XmStringFree(NodeLabelString);

    if(SuperNode)
    {
      ac = 0; 
      XtSetArg(al[ac],XmNarcDirection, XmDIRECTED); ac++;
	if(_multiple_edge && UIGraphNode::NewCG){
		XtSetArg(al[ac],XmNmapLabel,"True"); ac++;
	}	
	else{
		XtSetArg(al[ac],XmNmapLabel,"False"); ac++;
	}	

      NewArc = XmCreateAttachedArc(GraphWidget,edgeLabel,SuperNode, NewNode,
                                   al,ac); 
      XtManageChild(NewArc);     

     }

    return NewNode;
   }    

   else
     return NULL;
}


void AvoidNew(Widget graph_part, XtPointer client, XmGraphCallbackStruct *calldata)
{
  /* To avoid creation of new nodes or arcs */
  if ((calldata->reason == XmCR_NEW_ARC) ||
      (calldata->reason == XmCR_NEW_NODE))
  calldata->doit=False;
}


void MoveHandling(Widget graph_part, XtPointer client, XmGraphCallbackStruct *calldata)
{
  if (calldata->reason == XmCR_ARC_MOVED)
  {
    calldata->doit=FALSE;
  }
  else
  {
    if ((calldata->reason == XmCR_NODE_MOVED) ||
    	(calldata->reason == XmCR_NODES_MOVED))
    {
    if (calldata->reason == XmCR_NODES_MOVED)
      {
    	XmGraphFixSelectedNodePos(graph_part,True);
      }
      XmUpdateDisplay(graph_part);
    }
  
  }
  XmGraphUnmap(graph_part);
  XmGraphMap(graph_part);
  // XtUnmanageChild(graph_part);
  // XtManageChild(graph_part);
  // XmGraphCenterAroundWidget(Flowgraph,calldata->widget);
}


void UpdateGraph(int GraphNum)
{
      Arg al[5];  
      int ac;
 
     
      FGZoom = 0; 
	int num = cfg.GetSizeofFGnodes();
	for(int i=0; i<num; i++)
		cfg.FG_Nodes[i].SetUINode(NULL);
        XtUnmanageChild(Flowgraph);
	
      ac = 0;   
       XtSetArg(al[ac], XmNorientation,XmHORIZONTAL); ac++;
        XtSetArg(al[ac], XmNautoLayoutMode, XmALWAYS); ac++;
        XtSetArg(al[ac], XmNtwinsVisible, TRUE); ac++;
        XtSetArg(al[ac], XmNeditable, True); ac++;
        Flowgraph = XmCreateScrolledGraph(CFGmainform,"Flowgraph", al, ac);

        /*  allow moving of nodes */
        XtAddCallback (Flowgraph,
    		     XmNnodeMovedCallback,
    		     (XtCallbackProc)MoveHandling,   NULL);
         /* avoid moving of arcs */
        XtAddCallback (Flowgraph,
    		     XmNarcMovedCallback,
    		     (XtCallbackProc)MoveHandling,    NULL);
    
         /*  avoid creation of new arcs or nodes */
        XtAddCallback (Flowgraph,
    		     XmNnewNodeCallback,
    		     (XtCallbackProc)AvoidNew,     NULL);
      
        XtAddCallback (Flowgraph,
    		     XmNnewArcCallback,
    		     (XtCallbackProc)AvoidNew,      NULL);
   
       
        XtAddCallback (Flowgraph,
    		     XmNselectNodeCallback,
    		     (XtCallbackProc)LoadStatement,  NULL);
        /*
        XtAddCallback(Flowgraph,
    		    XmNselectArcCallback,
    		    (XtCallbackProc)CallSiteInfo,NULL);
        */




	ac = 0;

        XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM);ac++;
        XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM);ac++;
        XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM);ac++;
        XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM);ac++;
        XtSetValues (XtParent(XtParent(Flowgraph)), al,ac);
        XtManageChild (Flowgraph);

        XmGraphUnmap(Flowgraph);


        ac = 0;
        char templabel[100];
        strcpy(templabel,"Flowgraph : ");
        strcat(templabel,(const char*)UICallgraphRoot[GraphNum].GetName());
        XmString tempstring = XmStringCreateLtoR (templabel, (XmStringCharSet)XmFONTLIST_DEFAULT_TAG );
	XtSetArg(al[ac], XmNlabelString, tempstring); ac++;
	XtSetValues(CFGFlowgraphLabel, al, ac );
        XmStringFree ( tempstring);


      // XtSetSensitive(GraphShell,False);
      // XtSetSensitive(GraphForm,False);
      // XtUnmanageChild(ControlflowForm);
 
	// XmGraphUnmap(Flowgraph);
       //  XtUnmanageChild(XtParent(Flowgraph));   
     
      // XmGraphDestroyAllArcs(Flowgraph);
      // XmGraphDestroyAllNodes(Flowgraph);




      // XtManageChild(GraphShell); 
      //  XmGraphDestroyAllArcs(Flowgraph);
      // XtDestroyWidget(Flowgraph);
      // XtDestroyWidget(ControlflowForm); 
      //       for (int i = 0; i <UIGraphNode::NumOfNodes; i++)
      // { 
     
      ProcedureLoaded = GraphNum;
        
      // XmUpdateDisplay(ControlflowForm);
     
       
     
      
       
       CreateFlowgraph(GraphNum);
      
         XmGraphMap(Flowgraph);
	// XtManageChild(XtParent(Flowgraph));
	// XtManageChild(ControlflowForm);
       // XtSetSensitive(GraphShell,True);
       //  XtSetSensitive(GraphForm,True);


       // XtUnmanageChild(GraphShell);
       //XtUnmanageChild(GraphForm);
        if(cfg.GetSizeofFGnodes()>0){
       XmGraphCenterAroundWidget(Flowgraph,cfg.FG_Nodes[0].GetUINode());
       XmGraphSelectNode(Flowgraph,cfg.FG_Nodes[0].GetUINode());
	} 

}


void ZoomINCB(Widget , XtPointer, XtPointer)
{
  if(CGZoom<2) {
    // XmGraphUnmap(Callgraph);
   XmGraphZoom(Callgraph , .5);
   // XmGraphMap(Callgraph);
   CGZoom++;
    XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[ProcedureLoaded].GetUINode());
       XmGraphSelectNode(Callgraph,UICallgraphRoot[ProcedureLoaded].GetUINode());
  }

}
void ZoomOUTCB(Widget , XtPointer, XtPointer)
{
  if(CGZoom>-2)
    { 
      // XmGraphUnmap(Callgraph);
      XmGraphZoom(Callgraph , -.5);
      CGZoom--; 
       XmGraphCenterAroundWidget(Callgraph,UICallgraphRoot[ProcedureLoaded].GetUINode());
       XmGraphSelectNode(Callgraph,UICallgraphRoot[ProcedureLoaded].GetUINode());

      // XmGraphMap(Callgraph);
    }
}

/*
	Yi Wen added on 06/28/2003
	The function display extra edges into graph to enable multiple edges display 
*/
void addExtraEdge(){
	int totalArcNum=XmGraphNumArcs(Callgraph);
	WidgetList n=new Widget[totalArcNum];
	int numArc;
	Arg al;
   	XtSetArg(al,XmNmapLabel,"True"); 
  for (int i = 0; i <UIGraphNode::NumOfNodes; i++)
  { 
   
	int realSuccs,singleSuccs;
	realSuccs=UICallgraphRoot[i].GetRealNumSuccs();
	singleSuccs=UICallgraphRoot[i].GetNumSuccs();

         	for (int j =0;j<singleSuccs; j++){
             		int num;
             		num =  UICallgraphRoot[i].GetSuccsID(j);
			n=XmGraphGetArcsBetweenNodes(Callgraph,UICallgraphRoot[i].GetUINode(), 
			UICallgraphRoot[num].GetUINode(),&numArc);
			XtSetValues(n[0],&al,1);
			for(int k=1;k<numArc;k++){
				//XtSetValues(n[k],&al,1);
				XtManageChild(n[k]);
			}
		}
 
 }
	if(UIGraphNode::NewCG){
		XtSetSensitive(GraphCallchainButton,TRUE);
		XtSetSensitive(GraphNextedgeButton,TRUE);
		XtSetSensitive(GraphPreedgeButton,TRUE);
	}
	else{
		XtSetSensitive(GraphCallchainButton,FALSE);
		XtSetSensitive(GraphNextedgeButton,FALSE);
		XtSetSensitive(GraphPreedgeButton,FALSE);
	}
}
/*
	Yi Wen added on 06/28/2003
	The function hide extra edges into graph to disable multiple edges display 
*/
void clearExtraEdge(){
	int totalArcNum=XmGraphNumArcs(Callgraph);
	WidgetList n=new Widget[totalArcNum];
	int numArc;
	Arg al;
   	XtSetArg(al,XmNmapLabel,"False"); 
  	for (int i = 0; i <UIGraphNode::NumOfNodes; i++){
		int singleSuccs;
		singleSuccs=UICallgraphRoot[i].GetNumSuccs();
         	for (int j =0;j<singleSuccs; j++){
             		int num;
             		num =  UICallgraphRoot[i].GetSuccsID(j);
			n=XmGraphGetArcsBetweenNodes(Callgraph,UICallgraphRoot[i].GetUINode(), 
			UICallgraphRoot[num].GetUINode(),&numArc);
			XtSetValues(n[0],&al,1);
			for(int k=1;k<numArc;k++){
				//XtSetValues(n[k],&al,1);
				XtUnmanageChild(n[k]);
			}
		}
	}
	clearNotice(callchainArcs,GraphCallchainButton);
	clearNotice(nextArc,GraphNextedgeButton);
	clearNotice(preArc,GraphPreedgeButton);
}

/*
	Yi Wen added on 06/30/2003
	The function is to prepare the edge label
*/
char* prepareEdgeLabel(int idx,int succ){
	int edge=UICallgraphRoot[idx].GetEdgeID(succ);
	int pre_edge=UICallgraphRoot[idx].GetPreEdgeID(succ);
	char* label=new char[100];
	sprintf(label,"%d/%d",edge,pre_edge);
	return label;	

}
/*
	Yi Wen added on 06/27/2003
	The function deal with multiple edge display in call graph
*/
extern void toggleMultiEdge(Widget toggle, XtPointer app_data,
   XtPointer widget_data){
	if (((XmToggleButtonCallbackStruct *)widget_data)->set) {
		if(!_multiple_edge){
			_multiple_edge=1;
			addExtraEdge();
		}
	}else{
		if(_multiple_edge){
			_multiple_edge=0;
			clearExtraEdge();
		}
	}
}

/*
	Yi Wen added on 06/30/2003
	. mark current arc
	. find UIClass for from node
	. find index for the selected Arc in from node
	. if previous edge is not -1, find previous arc
	. find UIClassNode for from node of previous arc
	. if node is not null, recursivly to invoke this function 
	
	:TODO find alternative chains
*/
/*
void markArcInCallchain(UIGraphNode fromNode, int arc_idx){
	//mark
	Arg al;
	Widget arc=callgraphArcs[fromNode.GetCallgraphArcsIndex(arc_idx)];
	XtSetArg(al,XmNforeground,"yellow");
	XtSetValues(arc,&al,1);				
	
	int pre_idx=fromNode.GetPreEdgeID(arc_idx);			
	cout<<"pre_idx: "<<pre_idx<<"\n";
	if(pre_idx>-1){
		//painful. have to check all nodes and all edges 
		int p=0;
		int ed_idx=0;
		int find=0;
		while(p<UIGraphNode::NumOfNodes && !find){
			ed_idx=0;
			//cout<<"node: "<<UICallgraphRoot[p].GetName()<<
			//" ,num: "<<UICallgraphRoot[p].GetRealNumSuccs() <<"\n";
			int numSuccs=UICallgraphRoot[p].GetRealNumSuccs();
			while(ed_idx<numSuccs&&!find ){
				int edge_idx=UICallgraphRoot[p].GetEdgeID(ed_idx);
			//	cout<<"idx: "<<ed_idx<<" ,edge: "
			//	<<edge_idx<<"\n";
				if(edge_idx==pre_idx &&
			       	  UICallgraphRoot[UICallgraphRoot[p].GetSuccsID(ed_idx)].
				  GetLineNumber()==fromNode.GetLineNumber()){
					find=1;
				}
				ed_idx++;
			}
			p++;
		}
		if(find){
			cout<<"find!\n";
			markArcInCallchain(UICallgraphRoot[p-1],ed_idx-1);
		}else{
			cout<<"Cannot find previous edge!\n";
			exit;
		}
	}
}
*/
int findUINodesOfEdge(int edge,int *fromNode, int *toNode){
	for(int i=0;i<UIGraphNode::NumOfNodes;i++){
		for(int j=0;j<UICallgraphRoot[i].GetRealNumSuccs();j++){
			if(edge==UICallgraphRoot[i].GetEdgeID(j)){
				*fromNode=i;
				*toNode=UICallgraphRoot[i].GetSuccsID(j);
				return j;
			}	
		}
	}
	return -1;
}
void findUINodesOfArc(Widget arc,int *fromNode,int *toNode){
	Widget *from=new Widget;
	Widget *to=new Widget;
	
	XmGraphGetArcNodes(Callgraph,arc,from,to);
	//find from node in UIClassNode
	int curNode,findOne=0;
	for(curNode=0;curNode<UIGraphNode::NumOfNodes;curNode++){
		if(UICallgraphRoot[curNode].GetUINode()==*from){
			*fromNode=curNode;
	//		cout<<"fromNode: "<<*fromNode<<"in if \n";
			if(findOne)//find to already
				break;
			findOne=1;
		} 
		if(UICallgraphRoot[curNode].GetUINode()==*to){
			*toNode=curNode;
			if(findOne)//find to already
				break;
			findOne=1;
		}
	}
	if(curNode>=UIGraphNode::NumOfNodes){
		*fromNode=*toNode=-1;
	}
	//cout<<"fromNode: "<<*fromNode<<"b4 return \n";
}

int findSelectedEdgeInUINode(int curNode){
	int index=-1;
	//test eqaulity by testing selected state :
	Arg al1;
	for (int j =0; j<UICallgraphRoot[curNode].GetRealNumSuccs() ; j++){
		Widget arc1=UICallgraphRoot[curNode].GetCallgraphArcs(j);
		if(XmGraphIsSelectedArc(Callgraph,arc1)){
			index=j;
			break;
		}
	}
	return index;
}

void PrintErrorMessage(char Message[]){
	XmString ok      = XmStringCreateLocalized("OK") ;
	XmString message; 
	Arg      al[4] ;
	int ac=0;
	XtSetArg(al[ac], XmNokLabelString, ok); ac++; 
	XtSetArg(al[ac], XmNdialogStyle, XmDIALOG_SYSTEM_MODAL) ; ac++ ;
	message=XmStringCreateLocalized(Message);
	XtSetArg(al[ac], XmNmessageString, message) ; ac++ ;
	Widget error_dialog = XmCreateErrorDialog(GraphShell,
   	ErrorDialogTitle,al,ac);
	XtManageChild(error_dialog) ;
   	XmStringFree(message);	
   	XmStringFree(ok);	
}
void setArcNotice(Widget arc, char* color,int lineStyle){
	Arg al[2];
	int ac=0;
	XtSetArg(al[ac],XmNarcWidth,NOTICEArcWIDTH); ac++;
	XtSetArg(al[ac],XmNstyle,lineStyle); ac++;
	XtSetValues(arc,al,ac);
	ColorWidget(arc,color,False);
}
void unsetArcNotice(Widget arc){
	Arg al[2];
	int ac=0;
	XtSetArg(al[ac],XmNarcWidth,0); ac++;
	XtSetArg(al[ac],XmNstyle,XmLineSolid); ac++;
	XtSetValues(arc,al,ac);
	ColorWidget(arc,ArcForeground,False);
}

void clearNotice(vector<Widget> arcs,Widget button){
	for(int i=0;i<arcs.size();i++)
		unsetArcNotice(arcs[i]);
	XmToggleButtonSetState (button,False,False);
}
void markArcInCallchain(int fromNode, int arc_idx,int pre_idx){
	while(pre_idx>-1){
		//mark
		Widget arc=UICallgraphRoot[fromNode].GetCallgraphArcs(arc_idx);
		setArcNotice(arc, CALLCHAINSTYLE,CALLCHAINLINE);
		callchainArcs.push_back(arc);
		pre_idx=UICallgraphRoot[fromNode].GetPreEdgeID(arc_idx);			
		if(pre_idx==-1)
			return;
		int pre_caller=UICallgraphRoot[fromNode].GetPreCallerID(arc_idx);
		//cout<<"pre_idx: "<<pre_idx<<"edge: "<<UICallgraphRoot[fromNode].GetEdgeID(arc_idx)
//<<"\n";
		//painful. have to check all edges of this node
		int ed_idx=0;
		int find=0;
//		cout<<"node: "<<UICallgraphRoot[pre_caller].GetName()<<
//		" ,num: "<<UICallgraphRoot[pre_caller].GetRealNumSuccs() <<"\n";
		int numSuccs=UICallgraphRoot[pre_caller].GetRealNumSuccs();
		while(ed_idx<numSuccs&&!find ){
			int edge_idx=UICallgraphRoot[pre_caller].GetEdgeID(ed_idx);
//		cout<<"idx: "<<ed_idx<<" ,edge: "
//		<<edge_idx<<"\n";
			if(edge_idx==pre_idx &&
		       	  UICallgraphRoot[UICallgraphRoot[pre_caller].GetSuccsID(ed_idx)].
			  GetLineNumber()==UICallgraphRoot[fromNode].GetLineNumber()){
				find=1;
			}
			ed_idx++;
		}
		if(find){
//			cout<<"find!\n";
			fromNode=pre_caller;
			arc_idx=ed_idx-1;
		}else if(pre_idx>-1){
			cout<<"Cannot find previous edge!\n";
			exit(0);
		}
	}
}
/*
	Yi Wen added on 06/30/2003
	The function is to show the call chain. 
	basic behavior:
		1. if user didn't choose an end edge(an edge connecting to a green node),
		   then remind user to choose one.
		2. if user choose multiple edges, remind user to choose only one end edge
		3. else pop up a window to show callchain based on the user's selection 
		
*/
void showCallchain(Widget show, XtPointer app_data,
   XtPointer widget_data){

	if (((XmToggleButtonCallbackStruct *)widget_data)->set) {
		//get user's selection	
		callchainArcs.clear();
		
		int totalArcNum=XmGraphNumArcs(Callgraph);
		WidgetList n=new Widget[totalArcNum];
		int* numSel=new int;
		n=XmGraphGetSelectedArcs(Callgraph,numSel);
		if(*numSel!=1){
			PrintErrorMessage("Please choose one and only one edge.");
			XmToggleButtonSetState (GraphCallchainButton,False,False);
			return;
		}
		int fromNode, toNode,index;
		findUINodesOfArc(n[0],&fromNode,&toNode);
		//cout<<"fromNode: "<<fromNode<<"\n";
		index=findSelectedEdgeInUINode(fromNode);
		if(index==-1){
			cout<<"error: cannot find edge\n";
			return;
		}
		markArcInCallchain(fromNode,index,0) ;
	}else{ //unset
		for(int i=0;i<callchainArcs.size();i++)
			unsetArcNotice(callchainArcs[i]);
		callchainArcs.clear();
	}	
}
/*
	basic behavior:
	param: 
		fromNode -- the tail node of arc
		toNode -- the head node of arc
		arc -- the index of arc in fromNode
*/
void markNextEdge(int fromNode,int toNode,int arc){
	int mark=0;
	nextArc.push_back(UICallgraphRoot[fromNode].GetCallgraphArcs(arc));
	//cout<<"arc: "<<arc<<", ID: "<<UICallgraphRoot[fromNode].GetEdgeID(arc)<<"\n";
	for(int j=0;j<UICallgraphRoot[toNode].GetRealNumSuccs();j++){
	//	cout<<"pre: "<<UICallgraphRoot[toNode].GetPreEdgeID(j)<<"\n";

		if(UICallgraphRoot[toNode].GetPreEdgeID(j)==
			UICallgraphRoot[fromNode].GetEdgeID(arc)){
			setArcNotice(UICallgraphRoot[toNode].GetCallgraphArcs(j),NEXTEDGESTYLE,NEXTEDGELINE);
			nextArc.push_back(UICallgraphRoot[toNode].GetCallgraphArcs(j));
			mark=1;
		}
	}
	//fake edge
	if(UICallgraphRoot[fromNode].GetFakeEdgeID(arc) > -1){
		vector<int> f=fake_edges[UICallgraphRoot[fromNode].GetFakeEdgeID(arc)];
	//	cout<<"f.size(): "<<f.size()<<"\n";
		for(int i=0;i<f.size();i++){
			int from, to,edge_idx;			
			edge_idx=findUINodesOfEdge(f[i],&from,&to);
	//		cout<<"from: "<<from<<", to: "<<to<<", edge: "<<edge_idx<<"\n";
			if(edge_idx==-1){
				cout<<"error in markNextEdge!\n";
				return;
			}
			nextArc.push_back(UICallgraphRoot[from].GetCallgraphArcs(edge_idx));
			setArcNotice(UICallgraphRoot[from].GetCallgraphArcs(edge_idx),NEXTEDGESTYLE,NEXTEDGELINE);
			mark=1;
		}
	}
	if(!mark){
		PrintErrorMessage("No edge is next edge of selected edge.");
		XmToggleButtonSetState (GraphNextedgeButton,False,False);
	}else
		setArcNotice(nextArc[0],NEXTEDGESTYLE,NEXTEDGELINE);
}
/*
	Yi Wen added on 07/03/2003
	The function is to display next edge of selected edge. 
*/
void showNextEdge(Widget show, XtPointer app_data,
   XtPointer widget_data){
	if (((XmToggleButtonCallbackStruct *)widget_data)->set) {
		nextArc.clear();
		//get user's selection	
		int totalArcNum=XmGraphNumArcs(Callgraph);
		WidgetList n=new Widget[totalArcNum];
		int* numSel=new int;
		n=XmGraphGetSelectedArcs(Callgraph,numSel);
		if(*numSel!=1){
			PrintErrorMessage("Please choose one and only one edge.");
			XmToggleButtonSetState (GraphNextedgeButton,False,False);
			return;
		}
		int fromNode, toNode,index;
		findUINodesOfArc(n[0],&fromNode,&toNode);
		//cout<<"find Nodes, from: "<<fromNode<<", to: "<<toNode<<"\n";
		index=findSelectedEdgeInUINode(fromNode);
		//cout<<"find edge, index: "<<index<<"\n";
		if(index==-1){
			cout<<"error: cannot find edge\n";
			return;
		}
		markNextEdge(fromNode,toNode,index) ;
	}else{ //unset
		for(int i=0;i<nextArc.size();i++)
			unsetArcNotice(nextArc[i]);
		nextArc.clear();
	}
}

void markPreEdge(int fromNode,int toNode,int arc){
	preArc.push_back(UICallgraphRoot[fromNode].GetCallgraphArcs(arc));
	//cout<<"arc: "<<arc<<", ID: "<<UICallgraphRoot[fromNode].GetEdgeID(arc)<<"\n";
	//get previous edge:
	int edge_id=UICallgraphRoot[fromNode].GetPreEdgeID(arc);
	int i=0;
	int j=0;
	bool find=False;
	while(i<UICallgraphRoot[fromNode].GetParentsSize()&&!find){
		int pa=UICallgraphRoot[fromNode].GetParents(i);
		while(j<UICallgraphRoot[pa].GetRealNumSuccs()&&!find){
			if(UICallgraphRoot[pa].GetEdgeID(j)==edge_id){
				setArcNotice(UICallgraphRoot[pa].GetCallgraphArcs(j),PREEDGESTYLE,NEXTEDGELINE);
				preArc.push_back(UICallgraphRoot[pa].GetCallgraphArcs(j));
				find=True;
			}
			j++;
		}
		i++;
	}

	//fake edge
	edge_id=UICallgraphRoot[fromNode].GetEdgeID(arc);
	for(i=0;i<UICallgraphRoot[fromNode].GetParentsSize();i++){
		int pa=UICallgraphRoot[fromNode].GetParents(i);
		for(j=0;j<UICallgraphRoot[pa].GetRealNumSuccs();j++){
			if(UICallgraphRoot[pa].GetFakeEdgeID(j) > -1){
				vector<int> f=fake_edges[UICallgraphRoot[pa].GetFakeEdgeID(j)];
				for(int k=0;k<f.size();k++){
					if(f[k]==edge_id){
						setArcNotice(UICallgraphRoot[pa].GetCallgraphArcs(j),PREEDGESTYLE,PREEDGELINE);	
						preArc.push_back(UICallgraphRoot[pa].GetCallgraphArcs(j));
						find=True;
					}
				}
			}
		}
	}
	if(!find){
		PrintErrorMessage("No edge is previous edge of selected edge.");
		XmToggleButtonSetState (GraphPreedgeButton,False,False);
	}else{
		setArcNotice(preArc[0],PREEDGESTYLE,PREEDGELINE);
	}
}
/*
	Yi Wen added on 07/03/2003
	The function is to display next edge of selected edge. 
*/
void showPreEdge(Widget show, XtPointer app_data,
   XtPointer widget_data){
	if (((XmToggleButtonCallbackStruct *)widget_data)->set) {
		//get user's selection	
		preArc.clear();
		int totalArcNum=XmGraphNumArcs(Callgraph);
		WidgetList n=new Widget[totalArcNum];
		int* numSel=new int;
		n=XmGraphGetSelectedArcs(Callgraph,numSel);
		if(*numSel!=1){
			PrintErrorMessage("Please choose one and only one edge.");
			XmToggleButtonSetState (GraphPreedgeButton,False,False);
			return;
		}
		int fromNode, toNode,index;
		findUINodesOfArc(n[0],&fromNode,&toNode);
		index=findSelectedEdgeInUINode(fromNode);
		if(index==-1){
			cout<<"error: cannot find edge\n";
			return;
		}
		markPreEdge(fromNode,toNode,index) ;
	}else{ //unset
		for(int i=0;i<preArc.size();i++)
			unsetArcNotice(preArc[i]);
		preArc.clear();
	}
}
// Generate VCG file and display it in xvcg
extern void PrintCallgraph(Widget, XtPointer,  XtPointer)
{
   PrintGraph myPrint;

   for (int i = 0; i <UIGraphNode::NumOfNodes; i++){ 
      char title[10];
      sprintf(title,"%d",i);
      GraphNode myNode(title, UICallgraphRoot[i].GetName());
      
      if(i==rootnode && RootNodeDetected){
        myNode.setColor('b');
      }
      
      if(UICallgraphRoot[i].GetNumSuccs()==0){
	  myNode.setColor('l');
      }
      if(UICallgraphRoot[i].GetHasParent()==TRUE){
	  myNode.setColor('r');
      }
       if(UICallgraphRoot[i].GetMP()){
        myNode.setColor('o');
       }
//      cout << "title ===" << UICallgraphRoot[i].GetName() <<  UICallgraphRoot[i].GetNumSuccs() <<endl;
      for (int j =0; j<UICallgraphRoot[i].GetNumSuccs(); j++){
//             int num;
//             num =  UICallgraphRoot[i].GetSuccsID(j);
	     sprintf(title,"%d",UICallgraphRoot[i].GetSuccsID(j));
//	     cout << "title ===" << title <<endl;
	     myNode.setEdge(title);
       } 
       myPrint.addNode(myNode);
  }
  myPrint.printNodes("callgraph.vcg","Call Graph");
  system("xvcg callgraph.vcg&");  
}


void ColorWidget(Widget w, char color[],bool bg)
{
         int ac = 0;
	Arg al[2];
        XrmValue from_value, to_value;
	from_value.addr = color ;
	from_value.size = strlen( from_value.addr ) + 1;
	to_value.addr = NULL;
        if (GraphFormTop!=NULL)
	XtConvertAndStore (GraphFormTop, XmRString, &from_value, XmRPixel, &to_value);
        else
          if (CFGraphForm!=NULL)
            XtConvertAndStore (CFGraphForm, XmRString, &from_value, XmRPixel, &to_value);
        else
          if (DDGraphForm!=NULL) 
             XtConvertAndStore (DDGraphForm, XmRString, &from_value, XmRPixel, &to_value);       
          else return;   
	if ( to_value.addr )
	{
		if(bg){
			XtSetArg(al[ac], XmNbackground, (*((Pixel*) to_value.addr))); ac++;
		}
		else{
			XtSetArg(al[ac], XmNforeground, (*((Pixel*) to_value.addr))); ac++; 
		}
	}
       
	XtSetValues ( w, al, ac ); 


}



extern char *itoa(int i)
{
	char *s=(char*) malloc(42); /* Enough for a 128 bit integer */
	if (s) sprintf(s,"%d",i);
	return s;
}




